/* Generated by Together */

package es.altia.agora.business.registro.persistence;

import es.altia.common.service.config.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import es.altia.agora.business.registro.RegistroEntradaSalidaValueObject;
import es.altia.agora.business.registro.RegistroValueObject;
import es.altia.agora.business.registro.persistence.manual.RegistroAperturaCierreDAO;
import es.altia.agora.business.registro.exception.AbrirCerrarRegistroException;

import java.util.Date;
import java.sql.Connection;

public class RegistroAperturaCierreManager{
    /**
     * Esto es un código que sigue el patrón de diseño <code>Singleton</code>
     * Los métodos de negocio gestionan que la persistencia sea manual o automática
     * Es protected, por lo que la única manera de instanciar esta clase es usando el factory method <code>getInstance</code>
     */
    protected RegistroAperturaCierreManager() {
    //Queremos usar el fichero de configuración technical
    m_ConfigTechnical = ConfigServiceHelper.getConfig("techserver");
    //Queremos tener acceso a los mensajes de error localizados
    m_ConfigError = ConfigServiceHelper.getConfig("error");
    }

    /**
     * Intenta cargar la información sobre el registro (librillo).
     * @param SelectValueObject. Un Value Object conteniendo los parametros de la Select
     * @exception SelectException si hay algun problema con el contexto de la Select
     */
    public void getRegistroValue(RegistroEntradaSalidaValueObject regESVO, String[] parametros)
    throws AbrirCerrarRegistroException {
    //queremos estar informados de cuando este metodo es ejecutado
    m_Log.debug("getRegistroEntradaSalidaValue");


    try {
        m_Log.debug("Usando persistencia manual");

        RegistroAperturaCierreDAO.getInstance().load(regESVO,parametros);

        m_Log.debug("Registro obtenido de la BD");
        //We want to be informed when this method has finalized
        m_Log.debug("getRegistroValue");

    } catch (Exception ce) {
        m_Log.error("JDBC Technical problem " + ce.getMessage());
        throw new AbrirCerrarRegistroException("Problema técnico de JDBC " + ce.getMessage());

    }
    }



    public void updateRegistroValue(RegistroEntradaSalidaValueObject regESVO, String[] params)
    throws AbrirCerrarRegistroException {
    //queremos estar informados de cuando este metodo es ejecutado
    m_Log.debug("getRegistroEntradaSalidaValue");


    try {
        m_Log.debug("Usando persistencia manual");

        RegistroAperturaCierreDAO.getInstance().modify(regESVO,params);

        m_Log.debug("Registro obtenido de la BD");
        //We want to be informed when this method has finalized
        m_Log.debug("getRegistroValue");

    } catch (Exception ce) {
        m_Log.error("JDBC Technical problem " + ce.getMessage());
        throw new AbrirCerrarRegistroException("Problema técnico de JDBC " + ce.getMessage());

    }
    }


/*
   public Date getFechaRegistroAbierto(String tipoApertura)
       throws AbrirCerrarRegistroException{

      Date fechaRegistroAbierto=null;

    m_Log.debug("getFechaRegistroAbierto");

    try {

        m_Log.debug("Usando persistencia manual");

        fechaRegistroAbierto = RegistroAperturaCierreDAO.getInstance().getFechaRegistroAbierto(tipoApertura);

        m_Log.debug("Fecha de Registro abierto obtenida");

        //We want to be informed when this method has finalized
        m_Log.exit("getFechaRegistroAbierto");

    } catch (Exception ce) {
        fechaRegistroAbierto = null;
        m_Log.error("JDBC Technical problem " + ce.getMessage());
        throw new AbrirCerrarRegistroException("Problema técnico de JDBC " + ce.getMessage());
    }

    return fechaRegistroAbierto;
  }

*/
    public Date getFechaRegistroAbierto(RegistroValueObject registro, String[] params)
       throws AbrirCerrarRegistroException{

           Date fechaRegistroAbierto=null;

       m_Log.debug("getFechaRegistroAbierto");

       try {

       m_Log.debug("Usando persistencia manual");

       fechaRegistroAbierto = RegistroAperturaCierreDAO.getInstance().getFechaRegistroAbierto(registro,params);

       m_Log.debug("Fecha de Registro abierto obtenida");

       //We want to be informed when this method has finalized
       m_Log.debug("getFechaRegistroAbierto");

       } catch (Exception ce) {
               fechaRegistroAbierto = null;
       m_Log.error("JDBC Technical problem " + ce.getMessage());
       throw new AbrirCerrarRegistroException("Problema técnico de JDBC " + ce.getMessage());
       }

        return fechaRegistroAbierto;
  }


  public Date getFechaRegistroCerrado(RegistroValueObject registro, String[] params)
       throws AbrirCerrarRegistroException{

           Date fechaRegistroCerrado=null;

       m_Log.debug("getFechaRegistroCerrado");

       try {

       m_Log.debug("Usando persistencia manual");

       fechaRegistroCerrado = RegistroAperturaCierreDAO.getInstance().getFechaRegistroCerrado(registro,params);

       m_Log.debug("Fecha de Registro cerrado obtenida");

       //We want to be informed when this method has finalized
       m_Log.debug("getFechaRegistroCerrado");

       } catch (Exception ce) {
               fechaRegistroCerrado = null;
       m_Log.error("JDBC Technical problem " + ce.getMessage());
       throw new AbrirCerrarRegistroException("Problema técnico de JDBC " + ce.getMessage());
       }

        return fechaRegistroCerrado;
  }


/*
   public Date getFechaRegistroAbierto(Connection c, String tipoApertura)
       throws AbrirCerrarRegistroException{

      Date fechaRegistroAbierto=null;

    m_Log.debug("getFechaRegistroAbierto");

    try {

        m_Log.debug("Usando persistencia manual");

        fechaRegistroAbierto = RegistroAperturaCierreDAO.getInstance().getFechaRegistroAbierto(c, tipoApertura);

        m_Log.debug("Fecha de Registro abierto obtenida");

        //We want to be informed  when this method has finalized
        m_Log.exit("getFechaRegistroAbierto");

    } catch (Exception ce) {
        fechaRegistroAbierto = null;
        m_Log.error("JDBC Technical problem " + ce.getMessage());
        throw new AbrirCerrarRegistroException("Problema técnico de JDBC " + ce.getMessage());
    }

    return fechaRegistroAbierto;
  }

  */
  public Date getFechaRegistroAbierto(Connection c, RegistroValueObject registro)
        throws AbrirCerrarRegistroException{

            Date fechaRegistroAbierto=null;

        m_Log.debug("getFechaRegistroAbierto");

        try {

        m_Log.debug("Usando persistencia manual");

        fechaRegistroAbierto = RegistroAperturaCierreDAO.getInstance().getFechaRegistroAbierto(c, registro);

        m_Log.debug("Fecha de Registro abierto obtenida");

        //We want to be informed when this method has finalized
        m_Log.debug("getFechaRegistroAbierto");

        } catch (Exception ce) {
            fechaRegistroAbierto = null;
        m_Log.error("JDBC Technical problem " + ce.getMessage());
        throw new AbrirCerrarRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }

         return fechaRegistroAbierto;
  }

  public Date getFechaRegistroCerrado(Connection c, RegistroValueObject registro)
        throws AbrirCerrarRegistroException{

            Date fechaRegistroCerrado=null;

        m_Log.debug("getFechaRegistroCerrado");

        try {

        m_Log.debug("Usando persistencia manual");

        fechaRegistroCerrado = RegistroAperturaCierreDAO.getInstance().getFechaRegistroCerrado(c, registro);

        m_Log.debug("Fecha de Registro abierto obtenida");

        //We want to be informed when this method has finalized
        m_Log.debug("getFechaRegistroCerrado");

        } catch (Exception ce) {
            fechaRegistroCerrado = null;
        m_Log.error("JDBC Technical problem " + ce.getMessage());
        throw new AbrirCerrarRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }

         return fechaRegistroCerrado;
  }



   /**
     * Factory method para el <code>Singelton</code>.
     * @return La unica instancia de SelectManager
     */
    public static RegistroAperturaCierreManager getInstance() {
    //Si no hay una instancia de esta clase tenemos que crear una
    if (instance == null) {
    // Necesitamos sincronización aquí para serializar (no multithread)
    // las invocaciones a este metodo
    synchronized(RegistroAperturaCierreManager.class) {
        if (instance == null) {
        instance = new RegistroAperturaCierreManager();
        }
    }
    }
    return instance;
    }

    private static RegistroAperturaCierreManager instance = null; // Mi propia instancia usada en el metodo getInstance

    /*
     * Declaracion de servicios
     */

    protected static Config m_ConfigTechnical; // Para el fichero de configuracion technical
    protected static Config m_ConfigError; // Para el fichero de mensajes de error localizados
    protected static Log m_Log =
            LogFactory.getLog(RegistroAperturaCierreManager.class.getName());
}
