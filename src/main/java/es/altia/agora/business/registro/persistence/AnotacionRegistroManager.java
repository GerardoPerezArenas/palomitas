/* Generated by Together */

package es.altia.agora.business.registro.persistence;

import es.altia.agora.business.administracion.mantenimiento.persistence.manual.OrganizacionesDAO;
import es.altia.agora.business.administracion.mantenimiento.persistence.manual.UORDTO;
import es.altia.agora.business.documentos.DocumentoManager;
import es.altia.agora.business.documentos.helper.CodigoSeguroVerificacionHelper;
import es.altia.agora.business.escritorio.UsuarioValueObject;
import es.altia.agora.business.registro.DocumentoMetadatosVO;
import es.altia.agora.business.registro.TablaMetadatos;
import es.altia.agora.business.sge.plugin.documentos.vo.DocumentoBBDD;
import es.altia.agora.business.registro.DocumentoValueObject;
import es.altia.agora.business.registro.HistoricoMovimientoValueObject;
import es.altia.agora.business.util.HistoricoAnotacionHelper;
import es.altia.agora.business.util.HistoricoMailVO;
import es.altia.common.service.mail.MailHelper;
import es.altia.common.service.config.*;
import es.altia.common.exception.TechnicalException;
import org.apache.commons.logging.Log; 
import org.apache.commons.logging.LogFactory;
import es.altia.agora.business.registro.RegistroValueObject;
import es.altia.agora.business.registro.SimpleRegistroValueObject;
import es.altia.agora.business.sge.MetadatosDocumentoVO;
import es.altia.agora.business.registro.persistence.manual.AnotacionRegistroDAO;
import es.altia.agora.business.registro.exception.AnotacionRegistroException;
import es.altia.agora.business.registro.mantenimiento.MantAsuntosValueObject;
import es.altia.agora.business.sge.DocumentoAnotacionRegistroVO;
import es.altia.agora.business.sge.plugin.documentos.AlmacenDocumento;
import es.altia.agora.business.sge.plugin.documentos.AlmacenDocumentoTramitacionFactoria;
import es.altia.agora.business.sge.plugin.documentos.exception.AlmacenDocumentoTramitacionException;
import es.altia.agora.business.sge.plugin.documentos.vo.Documento;
import es.altia.agora.business.sge.plugin.documentos.vo.DocumentoTramitacionFactoria;
import es.altia.agora.business.sge.persistence.manual.InteresadosDAO;
import es.altia.agora.business.terceros.TercerosValueObject;

import es.altia.agora.business.util.GeneralValueObject;
import es.altia.agora.business.util.jdbc.SigpGeneralOperations;
import es.altia.agora.technical.ConstantesDatos;
import es.altia.flexia.registro.digitalizacion.lanbide.persistence.manual.DigitalizacionDocumentosLanbideDAO;
import es.altia.flexia.registro.digitalizacion.lanbide.util.DocumentoCatalogacionConversor;
import es.altia.flexia.registro.digitalizacion.lanbide.vo.DocumentoCatalogacionVO;
import es.altia.flexia.registro.justificante.util.FileOperations;
import es.altia.util.commons.DateOperations;
import es.altia.util.cache.CacheDatosFactoria;
import es.altia.util.commons.MimeTypes;
import es.altia.util.conexion.AdaptadorSQLBD;
import es.altia.util.conexion.BDException;
import java.io.File;
import java.util.Vector;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.HashMap;
import es.altia.util.persistance.KeyValueObject;
import java.io.ByteArrayInputStream;	
import java.io.ByteArrayOutputStream;
import java.util.Calendar;	
import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;
import java.util.List;
import org.apache.commons.io.FileUtils;	
import org.apache.commons.io.IOUtils;	
import org.apache.commons.lang.StringUtils;	
import org.apache.commons.lang.math.NumberUtils;

public class AnotacionRegistroManager {
    /**
     * Esto es un código que sigue el patrón de diseño <code>Singleton</code>
     * Los métodos de negocio gestionan que la persistencia sea manual o automática
     * Es protected, por lo que la única manera de instanciar esta clase es usando el factory method <code>getInstance</code>
     */
    protected AnotacionRegistroManager() {
        //Queremos usar el fichero de configuración technical
        m_ConfigTechnical = ConfigServiceHelper.getConfig("techserver");
        //Queremos tener acceso a los mensajes de error localizados
        m_ConfigError = ConfigServiceHelper.getConfig("error");

    }
    
    protected static Config registroConf = ConfigServiceHelper.getConfig("Registro");

	// Encapsula la nueva llamada en la firma como era antes de añadir la posibilidad de ser gestionada por 
	// transacciones externas
	public void insertRegistroValueObject(RegistroValueObject regESVO, String[] params) 
			throws AnotacionRegistroException, TechnicalException {
		insertRegistroValueObject(regESVO, params, null, false);
	}
	
	/**
	 * Guarda un registro y otros datos en la base de datos.
	 * 
	 * @param regESVO Registro a guardar.
	 * @param params Parametros de conexion a la base de datos.
	 * @param con Conexion a la base de datos.
	 * @param transaccionExterna Determina si se crea una transaccion durante el metodo o si esta  viene de una llamada 
	 * previa a este.
	 * @throws AnotacionRegistroException
	 * @throws TechnicalException 
	 */
    public void insertRegistroValueObject(RegistroValueObject regESVO, String[] params, Connection con, 
			boolean transaccionExterna) throws AnotacionRegistroException, TechnicalException {
        
        RegistroValueObject regVO = null;
        AdaptadorSQLBD oad = null;       
        
        ArrayList<String> rutasDocumentosNuevos = new ArrayList<String>();
        ArrayList<Integer> listaIndicesDocumentosNuevos     = new ArrayList<Integer>();
        ArrayList<Integer> listaIndicesDocumentosEliminados = new ArrayList<Integer>();

        m_Log.debug("insertRegistroValueObject");
        try {

            oad = new AdaptadorSQLBD(params);
			if (!transaccionExterna) {
				con = oad.getConnection();
				oad.inicioTransaccion(con);
			}
            regVO = AnotacionRegistroDAO.getInstance().insertRegistroValueObject(con, regESVO, params);
            
            if (regVO != null && regVO.getNumReg() > 0){
            
                if (("registrar_alta_entrada_denegada".equals(regVO.getRespOpcion())) || ("actualizacion_ya_realizada".equals(regVO.getRespOpcion())) ||
                        ("registrar_alta_sin_confirmar".equals(regVO.getRespOpcion())) || ("no_existe_expediente".equals(regVO.getRespOpcion()))) {
                    rollbackTransaccion(oad, con, transaccionExterna);
                } else{
                    
                    Vector docsAnt=regESVO.getListaDocsAnteriores();
                    //Inserta datos de los documentos entregados anteriormente 
                    if(docsAnt!=null && docsAnt.size()>0 && regVO.getRespOpcion().equals("registrar_alta_entrada_aceptada")){
                        
                        ArrayList<RegistroValueObject> docReg=new ArrayList<RegistroValueObject>();
                        ArrayList<RegistroValueObject> docsEntregadosAntNuevos=new ArrayList<RegistroValueObject>();
                        ArrayList<RegistroValueObject> docsEntregadosAntEliminados=new ArrayList<RegistroValueObject>();
                    
                        
                        for (int i = 0; i < docsAnt.size(); i++) {
                             RegistroValueObject regAnt = (RegistroValueObject) docsAnt.elementAt(i);
                             
                             m_Log.debug(" ==================> estadoDocumento: " + regAnt.getEstadoDocumentoRegistro());
                             if(regAnt.getEstadoEntregadoAnterior()==ConstantesDatos.ESTADO_DOCUMENTO_NUEVO){
                             // Si se trata de un nuevo elemento, se almacena en la lista de documentos a dar de alta 
                                regAnt.setAnoReg(regESVO.getAnoReg());
                                regAnt.setIdentDepart(regESVO.getIdentDepart());
                                regAnt.setUnidadOrgan(regESVO.getCodOficinaRegistro()); 
                                regAnt.setNumReg(regESVO.getNumReg());
                                regAnt.setTipoReg(regESVO.getTipoReg());
                                m_Log.debug("*******************DATOS***********************");
                                m_Log.debug("****************** AÑO REGISTRO"+regAnt.getAnoReg());
                                m_Log.debug("****************** DEPARTAMENTO"+regAnt.getIdentDepart());
                                m_Log.debug("****************** UOR"+regAnt.getUnidadOrgan());
                                m_Log.debug("****************** NUMERO REGISTRO"+regAnt.getNumReg());
                                m_Log.debug("****************** TIPO REGISTRO"+regAnt.getTipoReg());
                                
                                                              
                                docsEntregadosAntNuevos.add(regAnt);                                
                                                    
                            }else if(regAnt.getEstadoEntregadoAnterior()==ConstantesDatos.ESTADO_DOCUMENTO_ELIMINADO){
                                regAnt.setAnoReg(regESVO.getAnoReg());
                                regAnt.setIdentDepart(regESVO.getIdentDepart());
                                regAnt.setUnidadOrgan(regESVO.getCodOficinaRegistro());
                                regAnt.setNumReg(regESVO.getNumReg());
                                regAnt.setTipoReg(regESVO.getTipoReg());
                                                            
                                docsEntregadosAntEliminados.add(regAnt);                                
                            }
                                    
                        }

                        try{
                             AnotacionRegistroDAO dao=AnotacionRegistroDAO.getInstance();
                              try{
                                dao.insertarDocsEntregadosAnterior(con,docsEntregadosAntNuevos);
                               }catch (AnotacionRegistroException e) {
                                     m_Log.error("setEntregadosAnterior, error al insertar los documentos entregados anteriormente en base de datos: "+e.getMessage());
                                     throw new AlmacenDocumentoTramitacionException(1, "Error al dar de alta documento entregado anteriormente en base de datos: "+e.getMessage());
                                }
                             
                             
                             // Elimina los documentos marcados como eliminados
                             eliminarEntregadosAnterior(docsEntregadosAntEliminados,con);
                             
                             
                         }catch(AlmacenDocumentoTramitacionException e){
                             // Si se ha producido un error al insertar los documentos, hay que lanzar 
                             //  una AnotacionRegistroException para deshacer los cambios realizados en la BBDD
                             throw new AnotacionRegistroException(e.getMessage());
                         }
                              
                    }

                    Vector docs = regESVO.getListaDocsAsignados();

                    //Inserta los documentos asociados el registro
                    if (docs != null && docs.size() >0 && regVO.getRespOpcion().equals("registrar_alta_entrada_aceptada")){

                        //Obtiene la implementacion del plugin correspondiente                        
                        AlmacenDocumento almacen = AlmacenDocumentoTramitacionFactoria.getInstance(String.valueOf(regESVO.getIdOrganizacion())).getImplClassRegistro(String.valueOf(regESVO.getIdOrganizacion()));

                        ArrayList<Documento> docsReg = new ArrayList<Documento>();
                        int tipoDocumento = -1;
                        String descripcionOrganizacion = null;
                        String descripcionUnidadRegistro = null;
                        
                        if(!almacen.isPluginGestor()){
                            //Plugin BBDDD
                            tipoDocumento = DocumentoTramitacionFactoria.TIPO_DOCUMENTO_BBDD;
                        }else{
                            //Plugin Gestor Alfresco. Solo inserta los docuemntos en la BD de Flexia
                            tipoDocumento = DocumentoTramitacionFactoria.TIPO_DOCUMENTO_GESTOR;
                            descripcionOrganizacion = OrganizacionesDAO.getInstance().getDescripcionOrganizacion(regESVO.getIdOrganizacion(), con);
                            UORDTO uorDTO = (UORDTO)CacheDatosFactoria.getImplUnidadesOrganicas().getDatoClaveUnica(params[6],regESVO.getUnidOrgUsuarioQRegistra());
                            if (uorDTO!=null)
                                descripcionUnidadRegistro = uorDTO.getUor_nom();
                        }
                        
                        ArrayList<Documento> docsRegistroNuevos = new ArrayList<Documento>();
                        ArrayList<Documento> docsRegistroEliminados = new ArrayList<Documento>();
                        
                        int codOrganizacion = regESVO.getIdOrganizacion();                        
                        int codUnidadRegistro = Integer.parseInt(regESVO.getUnidOrgUsuarioQRegistra());                        
                        
                        for (int i = 0; i < docs.size(); i++) {
                             RegistroValueObject regDoc = (RegistroValueObject) docs.elementAt(i);
                             
                             m_Log.debug(" ==================> estadoDocumento: " + regDoc.getEstadoDocumentoRegistro());
                             if(regDoc.getEstadoDocumentoRegistro()==ConstantesDatos.ESTADO_DOCUMENTO_NUEVO &&  regDoc.getRutaDocumentoRegistroDisco()!=null && !"".equals( regDoc.getRutaDocumentoRegistroDisco())){
                                 // Si se trata de un nuevo elemento, se almacena en la lista de documentos
                                 // a dar de alta, y se lee su contenido 
                                String pathFile = regDoc.getRutaDocumentoRegistroDisco();
                                byte[] fichero = null;                    
                                try{
                                    File f = new File(pathFile);
                                    fichero = FileOperations.readFile(f);
                                
                                }catch(Exception e){
                                    e.printStackTrace();
                                }
                                                                
                                Hashtable<String,Object> datos = new Hashtable<String,Object>();
                                datos.put("identDepart",new Integer(regESVO.getIdentDepart()));
                                datos.put("unidadOrgan",new Integer(regESVO.getUnidadOrgan()));
                                datos.put("anoReg",new Integer(regESVO.getAnoReg()));
                                datos.put("numReg",new Long(regVO.getNumReg()));
                                datos.put("tipoReg",regESVO.getTipoReg());
                                datos.put("nombreDocumento",regDoc.getNombreDoc());
                                datos.put("tipoDoc",regDoc.getTipoDoc());
                                datos.put("fichero",fichero);
                                datos.put("idDocumento",new Long(regDoc.getIdDocumento()));
                                datos.put("fechaDoc",regDoc.getFechaDoc());
                                datos.put("entregado",regDoc.getEntregado());
                                datos.put("documentoRegistro",new Boolean(true));
                                datos.put("estadoDocumentoRegistro",regDoc.getEstadoDocumentoRegistro());
                                datos.put("rutaDocumento",regDoc.getRutaDocumentoRegistroDisco());
                                datos.put("params",params);
                                datos.put("codMunicipio",Integer.toString(codOrganizacion));
                                datos.put("tipoMime",regDoc.getTipoDoc());
                                datos.put("extension", MimeTypes.guessExtensionFromMimeType(regDoc.getTipoDoc()));
                                datos.put("longitudDocumento",fichero.length);
                                datos.put("documentoProcedimientoSinValor","false");
                                 // Metadatos del documento cotejo
                                rellenarMetadatosDocumentoCotejado(datos, regDoc);
                                
                                                                
                                if(almacen.isPluginGestor()){
                                    //  Si se trata de un plugin de un gestor documental, se pasa la información
                                    // extra necesaria                                    
                                    ResourceBundle config = ResourceBundle.getBundle("documentos");
                            
                                    String carpetaRaiz       = config.getString(ConstantesDatos.PREFIJO_PROPIEDAD_ALMACENAMIENTO + codOrganizacion + ConstantesDatos.BARRA + almacen.getNombreServicio() + ConstantesDatos.SUFIJO_PLUGIN_GESTOR_CARPETA_RAIZ);
                                    ArrayList<String> listaCarpetas = new ArrayList<String>();
                                    listaCarpetas.add(carpetaRaiz);
                                    listaCarpetas.add(codOrganizacion + ConstantesDatos.GUION + descripcionOrganizacion);
                                    listaCarpetas.add(codUnidadRegistro + ConstantesDatos.GUION + descripcionUnidadRegistro);
                                    
                                    if(regESVO.getTipoReg().equalsIgnoreCase("E"))
                                        listaCarpetas.add(ConstantesDatos.DESCRIPCION_ENTRADAS_REGISTRO);
                                    else
                                    if(regESVO.getTipoReg().equalsIgnoreCase("S"))
                                        listaCarpetas.add(ConstantesDatos.DESCRIPCION_SALIDAS_REGISTRO);    

                                    listaCarpetas.add(regESVO.getAnoReg() + ConstantesDatos.GUION + regESVO.getNumReg());
                                    datos.put("listaCarpetas",listaCarpetas);
                                }
                                
                                
                                Documento docReg = DocumentoTramitacionFactoria.getInstance().getDocumento(datos, tipoDocumento);                                
                                rutasDocumentosNuevos.add(regDoc.getRutaDocumentoRegistroDisco());
                                docsRegistroNuevos.add(docReg);                                
                                listaIndicesDocumentosNuevos.add(i);                                
                            }else
                            if(regDoc.getEstadoDocumentoRegistro()==ConstantesDatos.ESTADO_DOCUMENTO_ELIMINADO){
                                
                                Hashtable<String,Object> datos = new Hashtable<String,Object>();
                                datos.put("identDepart",new Integer(regESVO.getIdentDepart()));
                                datos.put("unidadOrgan",new Integer(regESVO.getUnidadOrgan()));
                                datos.put("anoReg",new Integer(regESVO.getAnoReg()));
                                datos.put("numReg",new Long(regVO.getNumReg()));
                                datos.put("tipoReg",regESVO.getTipoReg());
                                datos.put("nombreDocumento",regDoc.getNombreDoc());
                                datos.put("tipoDoc",regDoc.getTipoDoc());  
                                datos.put("idDocumento",new Long(regDoc.getIdDocumento()));
                                if(regDoc.getFechaDoc()!=null)
                                    datos.put("fechaDoc",regDoc.getFechaDoc());
                                else
                                    datos.put("fechaDoc","");
                                if(regDoc.getEntregado()!=null)
									datos.put("entregado",regDoc.getEntregado());
                                else
                                    datos.put("entregado","");
                                datos.put("documentoRegistro",new Boolean(true));
                                datos.put("params",params);
                                datos.put("codMunicipio",Integer.toString(codOrganizacion));
                                datos.put("tipoMime",regDoc.getTipoDoc());
                                datos.put("extension", MimeTypes.guessExtensionFromMimeType(regDoc.getTipoDoc()));
                                datos.put("documentoProcedimientoSinValor","false");
                                                                
                                datos.put("estadoDocumentoRegistro",regDoc.getEstadoDocumentoRegistro());
                                if(regDoc.getRutaDocumentoRegistroDisco()!=null)
                                    datos.put("rutaDocumento",regDoc.getRutaDocumentoRegistroDisco());
                                else
                                    datos.put("rutaDocumento","");
                                                                
                                // Metadatos del documento cotejo
                                rellenarMetadatosDocumentoCotejado(datos, regDoc);
                                
                                if(almacen.isPluginGestor()){
                                    //  Si se trata de un plugin de un gestor documental, se pasa la información
                                    // extra necesaria                                    
                                    ResourceBundle config = ResourceBundle.getBundle("documentos");                                 
                                    String carpetaRaiz       = config.getString(ConstantesDatos.PREFIJO_PROPIEDAD_ALMACENAMIENTO + codOrganizacion + ConstantesDatos.BARRA + almacen.getNombreServicio() + ConstantesDatos.SUFIJO_PLUGIN_GESTOR_CARPETA_RAIZ);
                                    
                                    ArrayList<String> listaCarpetas = new ArrayList<String>();
                                    listaCarpetas.add(carpetaRaiz);
                                    listaCarpetas.add(codOrganizacion + ConstantesDatos.GUION + descripcionOrganizacion);
                                    listaCarpetas.add(codUnidadRegistro + ConstantesDatos.GUION + descripcionUnidadRegistro);
                                    
                                    if(regESVO.getTipoReg().equalsIgnoreCase("E"))
                                        listaCarpetas.add(ConstantesDatos.DESCRIPCION_ENTRADAS_REGISTRO);
                                    else
                                    if(regESVO.getTipoReg().equalsIgnoreCase("S"))
                                        listaCarpetas.add(ConstantesDatos.DESCRIPCION_SALIDAS_REGISTRO);    

                                    listaCarpetas.add(regESVO.getAnoReg() + ConstantesDatos.GUION + regESVO.getNumReg());
                                    datos.put("listaCarpetas",listaCarpetas);
                                }
                                
                                
                                Documento docReg = DocumentoTramitacionFactoria.getInstance().getDocumento(datos, tipoDocumento);
                                listaIndicesDocumentosEliminados.add(i);                                
                                docsRegistroEliminados.add(docReg);                                
                            }else
                            if(regESVO.getCodProcedimiento()!=null && regESVO.getDescProcedimiento()!=null && regDoc.getEstadoDocumentoRegistro()==0 && regDoc.getRutaDocumentoRegistroDisco()==null){
                                // Si se  trata de un documento de inicio de procedimiento y no tiene valor, hay que insertarlo igualmente                                                              
                                Hashtable<String,Object> datos = new Hashtable<String,Object>();
                                datos.put("identDepart",new Integer(regESVO.getIdentDepart()));
                                datos.put("unidadOrgan",new Integer(regESVO.getUnidadOrgan()));
                                datos.put("anoReg",new Integer(regESVO.getAnoReg()));
                                datos.put("numReg",new Long(regVO.getNumReg()));
                                datos.put("tipoReg",regESVO.getTipoReg());
                                datos.put("nombreDocumento",regDoc.getNombreDoc());
                                datos.put("tipoDoc",regDoc.getTipoDoc());    
								datos.put("idDocumento",new Long(regDoc.getIdDocumento()));
                                if(regDoc.getDoc()!=null)
                                    datos.put("fichero",regDoc.getDoc());
                                else 
                                    datos.put("fichero","");
                                if(regDoc.getFechaDoc()!=null)
                                    datos.put("fechaDoc",regDoc.getFechaDoc());
                                else 
                                    datos.put("fechaDoc","");
                                if(regDoc.getEntregado()!=null){
									datos.put("entregado",regDoc.getEntregado());
                                }else{
                                    datos.put("entregado","");
                                }
                                datos.put("documentoRegistro",new Boolean(true));
                                datos.put("estadoDocumentoRegistro",regDoc.getEstadoDocumentoRegistro());                                
                                datos.put("params",params);
                                datos.put("codMunicipio",Integer.toString(codOrganizacion));
                                datos.put("tipoMime",regDoc.getTipoDoc());
                                datos.put("extension", MimeTypes.guessExtensionFromMimeType(regDoc.getTipoDoc()));
                                datos.put("longitudDocumento",0);                                
                                datos.put("documentoProcedimientoSinValor","true");
                                 // Metadatos del documento cotejo
                                rellenarMetadatosDocumentoCotejado(datos, regDoc);
                                                                
                                if(almacen.isPluginGestor()){
                                    //  Si se trata de un plugin de un gestor documental, se pasa la información
                                    // extra necesaria                                    
                                    ResourceBundle config = ResourceBundle.getBundle("documentos");
                            
                                    String carpetaRaiz       = config.getString(ConstantesDatos.PREFIJO_PROPIEDAD_ALMACENAMIENTO + codOrganizacion + ConstantesDatos.BARRA + almacen.getNombreServicio() + ConstantesDatos.SUFIJO_PLUGIN_GESTOR_CARPETA_RAIZ);
                                    ArrayList<String> listaCarpetas = new ArrayList<String>();
                                    listaCarpetas.add(carpetaRaiz);
                                    listaCarpetas.add(codOrganizacion + ConstantesDatos.GUION + descripcionOrganizacion);
                                    listaCarpetas.add(codUnidadRegistro + ConstantesDatos.GUION + descripcionUnidadRegistro);
                                    
                                    if(regESVO.getTipoReg().equalsIgnoreCase("E"))
                                        listaCarpetas.add(ConstantesDatos.DESCRIPCION_ENTRADAS_REGISTRO);
                                    else
                                    if(regESVO.getTipoReg().equalsIgnoreCase("S"))
                                        listaCarpetas.add(ConstantesDatos.DESCRIPCION_SALIDAS_REGISTRO);    

                                    listaCarpetas.add(regESVO.getAnoReg() + ConstantesDatos.GUION + regESVO.getNumReg());
                                    datos.put("listaCarpetas",listaCarpetas);
                                }
                                
                                Documento docReg = DocumentoTramitacionFactoria.getInstance().getDocumento(datos, tipoDocumento);                                
                                rutasDocumentosNuevos.add(regDoc.getRutaDocumentoRegistroDisco());
                                docsRegistroNuevos.add(docReg);                                
                                listaIndicesDocumentosNuevos.add(i);    
                                
                            }    
                                
                                
                            m_Log.debug(" ****************** EL DOCUMENTO " + regDoc.getNombreDoc() + " ******* CARECE DE ESTADO PORQUE ES DE PROCEDIMIENTO");
                                    
                        }

                        try{
                             almacen.setDocumentosRegistro(docsRegistroNuevos,con);
                             
                              // Se procede a eliminar los ficheros nuevos de la anotación que residen 
                             // en el disco del servidor
                             eliminarDocumentosRegistroNuevosServidor(rutasDocumentosNuevos);
                             
                             // Elimina los documentos marcados como eliminados, bien del disco o bien del gestor
                             eliminarDocumentos(almacen,docsRegistroEliminados,con);
                             
                             
                         }catch(AlmacenDocumentoTramitacionException e){
                             // Si se ha producido un error al insertar los documentos, hay que lanzar 
                             //  una AnotacionRegistroException para deshacer los cambios realizados en la BBDD
                             throw new AnotacionRegistroException(e.getMessage());
                         }
                    }
                }
            }
            
			commitTransaccion(oad, con, transaccionExterna);
                        
            m_Log.debug("Registro insertado correctamente");

            m_Log.debug("insertRegistroValueObject");

        } catch (BDException bde) {
            rollbackTransaccion(oad, con, transaccionExterna);
            Logger.getLogger(AnotacionRegistroDAO.class.getName()).log(Level.SEVERE, null, bde);
            throw new AnotacionRegistroException(m_ConfigError.getString("Error.AnotacionRegistroDAO.insercionDatosRegistro"), bde);
        } catch (Exception e) {
			rollbackTransaccion(oad, con, transaccionExterna);        
            Logger.getLogger(AnotacionRegistroDAO.class.getName()).log(Level.SEVERE, null, e);
            throw new AnotacionRegistroException(m_ConfigError.getString("Error.AnotacionRegistroDAO.insercionDatosRegistro"), e);
       }finally{
            devolverConexion(oad, con, transaccionExterna);
        }
    }
    
	/**
	 * Realiza un rollback en caso de que la transaccion no sea externa.
	 *
	 * @param oad Adaptador del gestor de base de datos.
	 * @param con Conexion a la base de datos.
	 * @param transaccionExterna Define si la transaccion es externa o no.
	 */
	private void rollbackTransaccion(AdaptadorSQLBD oad, Connection con, boolean transaccionExterna) throws TechnicalException {
		if (!transaccionExterna) {
			SigpGeneralOperations.rollBack(oad, con);
		}
	}

	/**
	 * Realiza un commit en caso de que la transaccion no sea externa.
	 *
	 * @param oad Adaptador del gestor de base de datos.
	 * @param con Conexion a la base de datos.
	 * @param transaccionExterna Define si la transaccion es externa o no.
	 */
	private void commitTransaccion(AdaptadorSQLBD oad, Connection con, boolean transaccionExterna) throws TechnicalException {
		if (!transaccionExterna) {
			SigpGeneralOperations.commit(oad, con);
		}
	}
	
	/**
	 * Realiza un devolver en caso de que la transaccion no sea externa.
	 *
	 * @param oad Adaptador del gestor de base de datos.
	 * @param con Conexion a la base de datos.
	 * @param transaccionExterna Define si la transaccion es externa o no.
	 */
	private void devolverConexion(AdaptadorSQLBD oad, Connection con, boolean transaccionExterna) throws TechnicalException {
		if (!transaccionExterna) {
			SigpGeneralOperations.devolverConexion(oad, con);
		}
	}

    public Vector getListaTiposDocumentos(String[] params)
            throws AnotacionRegistroException {

        Vector res;

        m_Log.debug("getListaTiposDocumentos");

        try {

            m_Log.debug("Usando persistencia manual");
            res = AnotacionRegistroDAO.getInstance().getListaTiposDocumentos(params);
            m_Log.debug("Tipos de documentos obtenidos");
            //We want to be informed when this method has finalized
            m_Log.debug("getListaTiposDocumentos");

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }

        return res;
    }
    
     public Vector getListaTiposDocumentosAlta(String[] params)	
            throws AnotacionRegistroException {	
        	
        Vector res;	
         	
        m_Log.debug("getListaTiposDocumentosAlta");	
        	
        try{	 
            m_Log.info("Usando persitencia manual");	
            res = AnotacionRegistroDAO.getInstance().getListaTiposDocumentosAlta(params);	
            m_Log.debug("Tipos de documentos obtenidos");	
        }catch(Exception e){	
            m_Log.error("JDBC Technical problem " + e.getMessage());	
            throw new AnotacionRegistroException("Problema tecnico de JDBC "+ e.getMessage());	
        }	
        	
        return res;	
    }

    public Vector getListaDocumentosJustificantes(String[] params)
            throws AnotacionRegistroException {

        Vector res;

        m_Log.debug("getListaDocumentosJustificantes");

        try {

            m_Log.debug("Usando persistencia manual");
            res = AnotacionRegistroDAO.getInstance().getListaDocumentosJustificantes(params);
            m_Log.debug("Tipos de PLANTILLAS obtenidos");
            //We want to be informed when this method has finalized
            m_Log.debug("getListaDocumentosJustificantes");

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }

        return res;
    }
 public String consultaXML(GeneralValueObject gVO,String[] params)  throws AnotacionRegistroException {

        //queremos estar informados de cuando este metodo es ejecutado
        m_Log.info("AnotacionRegistroDAO.consultaXML");

        String resultado="";
        try {
            resultado = AnotacionRegistroDAO.getInstance().consultaXML(gVO,params);
        } catch (Exception e) {
            m_Log.error("JDBC Technical problem " + e.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + e.getMessage());
        }
        return (resultado);
    }

    public Vector getListaDepartamentos(String[] params)
            throws AnotacionRegistroException {

        Vector res;

        m_Log.debug("getListaDepartamentos");

        try {

            m_Log.debug("Usando persistencia manual");
            res = AnotacionRegistroDAO.getInstance().getListaDepartamentos(params);
            m_Log.debug("Departamentos obtenidos");
            //We want to be informed when this method has finalized
            m_Log.debug("getListaDepartamentos");

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }

        return res;
    }


    public Vector getListaTiposRemitentes(String[] params)
            throws AnotacionRegistroException {

        Vector res;

        m_Log.debug("getListaTiposRemitentes");

        try {

            m_Log.debug("Usando persistencia manual");
            res = AnotacionRegistroDAO.getInstance().getListaTiposRemitentes(params);
            m_Log.debug("Tipos de Remitentes obtenidos");
            //We want to be informed when this method has finalized
            m_Log.debug("getListaTiposRemitentes");

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }

        return res;
    }


    public Vector getListaTiposTransportes(String[] params)
            throws AnotacionRegistroException {

        Vector res;

        m_Log.debug("getListaTiposTransportes");

        try {

            m_Log.debug("Usando persistencia manual");
            res = AnotacionRegistroDAO.getInstance().getListaTiposTransportes(params);
            m_Log.debug("Tipos de Transportes obtenidos");
            //We want to be informed when this method has finalized
            m_Log.debug("getListaTiposTransportes");

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }

        return res;
    }


    public Vector getListaActuaciones(String[] params)
            throws AnotacionRegistroException {

        Vector res;

        m_Log.debug("getListaActuaciones");

        try {

            m_Log.debug("Usando persistencia manual");
            res = AnotacionRegistroDAO.getInstance().getListaActuaciones(params);
            m_Log.debug("Tipos de Actuaciones obtenidos");
            //We want to be informed when this method has finalized
            m_Log.debug("getListaActuaciones");

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }

        return res;
    }


    public Vector getListaTemas(String[] params)
            throws AnotacionRegistroException {

        Vector res;

        m_Log.debug("getListaTemas");

        try {

            m_Log.debug("Usando persistencia manual");
            res = AnotacionRegistroDAO.getInstance().getListaTemas(params);
            m_Log.debug("Tipos de temas obtenidos");
            //We want to be informed when this method has finalized
            m_Log.debug("getListaTemas");

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }

        return res;
    }


    public RegistroValueObject getByPrimaryKey(RegistroValueObject registro, String[] params)
            throws AnotacionRegistroException {

        RegistroValueObject registroVO;

        m_Log.debug("getByPrimaryKey");

        try {
            m_Log.debug("Usando persistencia manual");
            registroVO = AnotacionRegistroDAO.getInstance().getByPrimaryKey(registro, params);
            m_Log.debug("Asiento recuperado");
        } catch (TechnicalException te) {
            m_Log.error("JDBC Technical problem " + te.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + te.getMessage());
        }
        return registroVO;
    }

    public RegistroValueObject getCampoAnotacionByPrimaryKey(RegistroValueObject registro, String campo, String[] params)
            throws AnotacionRegistroException {

        RegistroValueObject registroVO;
        AdaptadorSQLBD oad = new AdaptadorSQLBD(params);
        Connection con = null;

        try {
            con = oad.getConnection();
            
            m_Log.debug("Usando persistencia manual");
            registroVO = AnotacionRegistroDAO.getInstance().getCampoAnotacionByPrimaryKey(registro, campo, con);
            m_Log.debug("Valor recuperado");
        } catch (BDException bde) {
            m_Log.error("JDBC Technical problem " + bde.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + bde.getMessage());
        } catch (TechnicalException te) {
            m_Log.error("JDBC Technical problem " + te.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + te.getMessage());
        } finally {
            try {
                SigpGeneralOperations.devolverConexion(oad, con);
            } catch (TechnicalException ex) {
                m_Log.error("JDBC Technical problem " + ex.getMessage());
                throw new AnotacionRegistroException("Problema técnico de JDBC " + ex.getMessage());
            }
        }
        return registroVO;
    }

    
    
     public Vector<String> getDatosAnotacion(RegistroValueObject registro, String[] params)
            throws AnotacionRegistroException {

         m_Log.debug( "[getDatosAnotacion] parámetros: año=" + registro.getAnoReg() + ", num=" + registro.getNumReg() + ", tipo=" + registro.getTipoReg());
         AdaptadorSQLBD adapt = null;
        Connection con = null;
        Vector<String> resultado = new Vector<String>();
        
        m_Log.debug("getDatosAnotacion");
        try {
            m_Log.debug("Usando persistencia manual");
            adapt = new AdaptadorSQLBD(params);
            con = adapt.getConnection();
            
            RegistroValueObject registroVO = AnotacionRegistroDAO.getInstance().getDatosAnotacionById(registro, con, adapt);

            m_Log.debug( "[getDatosAnotacion] resultado tipoEntrada=" + registroVO.getTipoAnot());
            resultado.add(String.valueOf(registroVO.getIdentDepart()));//0-codDepartamento
            resultado.add(String.valueOf(registroVO.getUnidadOrgan()));//codUOR
            resultado.add(String.valueOf(registroVO.getTipoReg()));//tipoAnotacion
            resultado.add(String.valueOf(registroVO.getAnoReg()));//ejercicio
            resultado.add(String.valueOf(registroVO.getNumReg()));//numero
            resultado.add(registroVO.getFecEntrada());//5-fechaEntrada
            resultado.add(registroVO.getFecHoraDoc());//fechaDocumento
            resultado.add(registroVO.getAsunto());//asunto
            resultado.add(registroVO.getNombreInteresado());//nombreInteresado
            resultado.add(registroVO.getApellido1Interesado());//apell1Interesado
            resultado.add(registroVO.getApellido2Interesado());//10-apell2Interesado
            resultado.add(null);//relleno
            resultado.add(registroVO.getNomUniRegDestino());//destino
            resultado.add(String.valueOf(registroVO.getEstAnotacion()));//estado
            resultado.add(null);//relleno
            resultado.add(null);//15-relleno
            resultado.add(null);//relleno
            resultado.add(null);//relleno
            resultado.add(registroVO.getNumExpediente());//expediente relacionado
            resultado.add(registroVO.getDocumentoInteresado());
            resultado.add(registroVO.getCodAsunto());//20
            resultado.add(registroVO.getDescripcionAsunto());
            resultado.add(registroVO.getDocumentoInteresado());
            resultado.add(registroVO.getUsuarioQRegistra());
            resultado.add(registroVO.getObservaciones());//observaciones
            m_Log.debug("Asiento recuperado");
        } catch (TechnicalException te) {
            m_Log.error("JDBC Technical problem " + te.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + te.getMessage());
        } catch (BDException bde) {
            m_Log.error("Error al obtener una conexión a la BBDD.");
            throw new AnotacionRegistroException("Error al obtener una conexión a la BBDD.");
        } finally {
            try {
                if(con!=null) con.close();
            } catch (SQLException ex){
                m_Log.error("Error al cerrar la conexión a la BBDD");
            }
        }
        return resultado;
    }
     
          public Vector<String> getDatosAnotacionTecnicoReferencia(RegistroValueObject registro, String[] params)
            throws AnotacionRegistroException {

        AdaptadorSQLBD adapt = null;
        Connection con = null;
        Vector<String> resultado = new Vector<String>();
        
        m_Log.debug("getDatosAnotacion");
        try {
            m_Log.debug("Usando persistencia manual");
            adapt = new AdaptadorSQLBD(params);
            con = adapt.getConnection();
            
            RegistroValueObject registroVO = AnotacionRegistroDAO.getInstance().getDatosAnotacionById(registro, con, adapt);
            
            resultado.add(String.valueOf(registroVO.getIdentDepart()));//0-codDepartamento
            resultado.add(String.valueOf(registroVO.getUnidadOrgan()));//codUOR
            resultado.add(String.valueOf(registroVO.getTipoReg()));//tipoAnotacion
            resultado.add(String.valueOf(registroVO.getAnoReg()));//ejercicio
            resultado.add(String.valueOf(registroVO.getNumReg()));//numero
            resultado.add(registroVO.getFecEntrada());//5-fechaEntrada
            resultado.add(registroVO.getFecHoraDoc());//fechaDocumento
            resultado.add(registroVO.getAsunto());//asunto
            resultado.add(registroVO.getNombreInteresado());//nombreInteresado
            resultado.add(registroVO.getApellido1Interesado());//apell1Interesado
            resultado.add(registroVO.getApellido2Interesado());//10-apell2Interesado
            resultado.add(null);//relleno
            resultado.add(registroVO.getNomUniRegDestino());//destino
            resultado.add(String.valueOf(registroVO.getEstAnotacion()));//estado
            resultado.add(null);//relleno
            resultado.add(null);//15-relleno
            resultado.add(null);//relleno
            resultado.add(null);//relleno
            resultado.add(registroVO.getNumExpediente());//expediente relacionado
            resultado.add(registroVO.getDocumentoInteresado());
            resultado.add(registroVO.getCodAsunto());//20
            resultado.add(registroVO.getDescripcionAsunto());
            resultado.add(registro.getNombreTecnicoReferencia());
            resultado.add(null);//relleno
            resultado.add(registroVO.getObservaciones());//observaciones
            m_Log.debug("Asiento recuperado");
        } catch (TechnicalException te) {
            m_Log.error("JDBC Technical problem " + te.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + te.getMessage());
        } catch (BDException bde) {
            m_Log.error("Error al obtener una conexión a la BBDD.");
            throw new AnotacionRegistroException("Error al obtener una conexión a la BBDD.");
        } finally {
            try {
                if(con!=null) con.close();
            } catch (SQLException ex){
                m_Log.error("Error al cerrar la conexión a la BBDD");
            }
        }
        return resultado;
    }

    public void modify(RegistroValueObject regESVO, boolean digitFinalizada, String[] params)
            throws AnotacionRegistroException, TechnicalException {        

       RegistroValueObject regVO = null;        
       Connection con = null;
       AdaptadorSQLBD oad = null;    
       ArrayList<String> rutasDocumentosNuevos = new ArrayList<String>();
        
       m_Log.debug("modify");
        
        try {
            
            oad = new AdaptadorSQLBD(params);
            con = oad.getConnection();
            oad.inicioTransaccion(con);

            regVO = AnotacionRegistroDAO.getInstance().modify(con, regESVO, digitFinalizada, params);
            
            if (regVO != null && regVO.getNumReg() > 0){
            
               if (regVO.getRespOpcion().equals("modify_realizado") || regVO.getRespOpcion().equals("registrar_actualizacion_aceptada")){
                   
                    m_Log.debug("====>MODIFICANDO LISTA ENTREGADOS ANTERIORES");
                   Vector docsAnt=regESVO.getListaDocsAnteriores();
                   m_Log.debug(docsAnt.size());
                    //Inserta datos de los documentos entregados anteriormente 
                    if(docsAnt!=null && docsAnt.size()>0){
                        
                    m_Log.debug("======================>ENTRANDO  A MODIFICAR");
                        
                        ArrayList<RegistroValueObject> docReg=new ArrayList<RegistroValueObject>();
                        ArrayList<RegistroValueObject> docsEntregadosAntNuevos=new ArrayList<RegistroValueObject>();
                        ArrayList<RegistroValueObject> docsEntregadosAntEliminados=new ArrayList<RegistroValueObject>();
                        ArrayList<RegistroValueObject> docsEntregadosAntModificados=new ArrayList<RegistroValueObject>();
                        
                        for (int i = 0; i < docsAnt.size(); i++) {
                             RegistroValueObject regAnt = (RegistroValueObject) docsAnt.elementAt(i);
                             //regAnt.setEstadoDocumentoRegistro(0);
                             // CREAR ESTADO DOCUMENTO ANTERIOR NUEVO Y ELIMINADO;
                             m_Log.debug(" ==================> estado: " + regAnt.getEstadoEntregadoAnterior());
                             if(regAnt.getEstadoEntregadoAnterior()==ConstantesDatos.ESTADO_DOCUMENTO_NUEVO){
                             // Si se trata de un nuevo elemento, se almacena en la lista de documentos a dar de alta 
                                regAnt.setAnoReg(regESVO.getAnoReg());
                                regAnt.setIdentDepart(regESVO.getIdentDepart());
                                regAnt.setUnidadOrgan(regESVO.getUnidadOrgan());
                                regAnt.setNumReg(regESVO.getNumReg());
                                regAnt.setTipoReg(regESVO.getTipoReg());
                                m_Log.debug("*******************DATOS***********************");
                                m_Log.debug("****************** AÑO REGISTRO"+regAnt.getAnoReg());
                                m_Log.debug("****************** DEPARTAMENTO"+regAnt.getIdentDepart());
                                m_Log.debug("****************** UOR"+regAnt.getUnidadOrgan());
                                m_Log.debug("****************** NUMERO REGISTRO"+regAnt.getNumReg());
                                m_Log.debug("****************** TIPO REGISTRO"+regAnt.getTipoReg());
                                
                                                              
                                docsEntregadosAntNuevos.add(regAnt);                                
                                                    
                            }else if(regAnt.getEstadoEntregadoAnterior()==ConstantesDatos.ESTADO_DOCUMENTO_ELIMINADO){
                                regAnt.setAnoReg(regESVO.getAnoReg());
                                regAnt.setIdentDepart(regESVO.getIdentDepart());
                                regAnt.setUnidadOrgan(regESVO.getCodOficinaRegistro());
                                regAnt.setNumReg(regESVO.getNumReg());
                                regAnt.setTipoReg(regESVO.getTipoReg());
                                
                                //Documento docReg = DocumentoTramitacionFactoria.getInstance().getDocumento(datos, tipoDocumento);
                                                            
                                docsEntregadosAntEliminados.add(regAnt);                                
                            }else if(regAnt.getEstadoEntregadoAnterior()==ConstantesDatos.ESTADO_DOCUMENTO_MODIFICADO){
                                regAnt.setAnoReg(regESVO.getAnoReg());
                                regAnt.setIdentDepart(regESVO.getIdentDepart());
                                regAnt.setUnidadOrgan(regESVO.getCodOficinaRegistro());
                                regAnt.setNumReg(regESVO.getNumReg());
                                regAnt.setTipoReg(regESVO.getTipoReg());
                                
                                docsEntregadosAntModificados.add(regAnt);
                            }
                                    
                        }

                        try{
                             AnotacionRegistroDAO dao=AnotacionRegistroDAO.getInstance();
                              try{
                                dao.insertarDocsEntregadosAnterior(con,docsEntregadosAntNuevos);
                               }catch (AnotacionRegistroException e) {
                                     m_Log.error("setEntregadosAnterior, error al insertar los documentos entregados anteriormente en base de datos: "+e.getMessage());
                                     throw new AlmacenDocumentoTramitacionException(1, "Error al dar de alta documento entregado anteriormente en base de datos: "+e.getMessage());
                                }
                             
                             
                             // Elimina los documentos marcados como eliminados
                             eliminarEntregadosAnterior(docsEntregadosAntEliminados,con);
                             //Modifica los documentos anteriores marcados como modificados
                             modificarEntregadosAnterior(docsEntregadosAntModificados, con);
                             
                         }catch(AlmacenDocumentoTramitacionException e){
                             // Si se ha producido un error al insertar los documentos, hay que lanzar 
                             //  una AnotacionRegistroException para deshacer los cambios realizados en la BBDD
                             throw new AnotacionRegistroException(e.getMessage());
                         }
                               
                    }
                   
                   
                    Vector docs = regESVO.getListaDocsAsignados();
                    // se obtienen los documentos antes de modificaciones para conservar metadatos
                    Vector docsAntiguos = getListaDocumentos(regESVO, params);
                    
                    //se obtienen los metadatos de los documentos que se van a modificar
                    ArrayList metadatosDocumentosModificados = getMetadatosDocumentosModificados(docs, docsAntiguos, con);
                    
                    //Inserta los documentos asociados el registro
                    if (docs != null && docs.size() >0 ){ 

                        //Obtiene la implementacion del plugin correspondiente                                                
                        AlmacenDocumento almacen = AlmacenDocumentoTramitacionFactoria.getInstance(String.valueOf(regESVO.getIdOrganizacion())).getImplClassRegistro(String.valueOf(regESVO.getIdOrganizacion()));                        
                        ArrayList<Documento> docsRegistroNuevos = new ArrayList<Documento>();
                        ArrayList<Documento> docsRegistroEliminados = new ArrayList<Documento>();
                        
                        int tipoDocumento = -1;

                        if(!almacen.isPluginGestor()){
                            //Plugin BBDDD
                            tipoDocumento = DocumentoTramitacionFactoria.TIPO_DOCUMENTO_BBDD;
                        }else{
                            //Plugin Gestor Alfresco. Solo inserta los docuemntos en la BD de Flexia
                            tipoDocumento = DocumentoTramitacionFactoria.TIPO_DOCUMENTO_GESTOR;
                        }

                        int codOrganizacion = regESVO.getIdOrganizacion();
                        String descripcionOrganizacion = OrganizacionesDAO.getInstance().getDescripcionOrganizacion(regESVO.getIdOrganizacion(), con);
                        int codUnidadRegistro = Integer.parseInt(regESVO.getUnidOrgUsuarioQRegistra());
                        String descripcionUnidadRegistro = null;
                        UORDTO uorDTO = (UORDTO)CacheDatosFactoria.getImplUnidadesOrganicas().getDatoClaveUnica(params[6],regESVO.getUnidOrgUsuarioQRegistra());
                        if (uorDTO!=null)
                            descripcionUnidadRegistro = uorDTO.getUor_nom();
   
                        for (int i = 0; i < docs.size(); i++) {
                            RegistroValueObject regDoc = (RegistroValueObject) docs.elementAt(i);
                            m_Log.debug(" ===============> estadoDocumentoRegistro: " + regDoc.getEstadoDocumentoRegistro());
                            if(regDoc.getEstadoDocumentoRegistro()==ConstantesDatos.ESTADO_DOCUMENTO_NUEVO && regDoc.getRutaDocumentoRegistroDisco()!=null && !"".equals(regDoc.getRutaDocumentoRegistroDisco())){
                                 // Si se trata de un nuevo elemento, se almacena en la lista de documentos
                                 // a dar de alta, y se lee su contenido 
                                String pathFile = regDoc.getRutaDocumentoRegistroDisco();
                                byte[] fichero = null;                    
                                try{
                                    File f = new File(pathFile);
                                    fichero = FileOperations.readFile(f);
                                
                                }catch(Exception e){
                                    e.printStackTrace();
                                }
                                                                
                                Hashtable<String,Object> datos = new Hashtable<String,Object>();
                                datos.put("identDepart",new Integer(regESVO.getIdentDepart()));
                                datos.put("unidadOrgan",new Integer(regESVO.getUnidadOrgan()));
                                datos.put("anoReg",new Integer(regESVO.getAnoReg()));
                                datos.put("numReg",new Long(regVO.getNumReg()));
                                datos.put("tipoReg",regESVO.getTipoReg());
                                datos.put("nombreDocumento",regDoc.getNombreDoc());
                                datos.put("tipoDoc",regDoc.getTipoDoc());
                                datos.put("fichero",fichero);
                                datos.put("idDocumento",new Long(regDoc.getIdDocumento()));
                                datos.put("fechaDoc",regDoc.getFechaDoc());
                                datos.put("entregado",regDoc.getEntregado());
                                datos.put("documentoRegistro",new Boolean(true));
                                datos.put("estadoDocumentoRegistro",regDoc.getEstadoDocumentoRegistro());
                                datos.put("rutaDocumento",regDoc.getRutaDocumentoRegistroDisco());
                                datos.put("params",params);
                                datos.put("codMunicipio",Integer.toString(codOrganizacion));
                                datos.put("tipoMime",regDoc.getTipoDoc());
                                datos.put("extension", MimeTypes.guessExtensionFromMimeType(regDoc.getTipoDoc()));
                                datos.put("longitudDocumento",fichero.length);
                                                                                                
                                // Metadatos del documento cotejo
                                rellenarMetadatosDocumentoCotejado(datos, regDoc);
                                    
                                                                                                
                                if(almacen.isPluginGestor()){
                                    //  Si se trata de un plugin de un gestor documental, se pasa la información
                                    // extra necesaria                                    
                                    ResourceBundle config = ResourceBundle.getBundle("documentos");                                    
                                    String carpetaRaiz    = config.getString(ConstantesDatos.PREFIJO_PROPIEDAD_ALMACENAMIENTO + codOrganizacion + ConstantesDatos.BARRA + almacen.getNombreServicio() + ConstantesDatos.SUFIJO_PLUGIN_GESTOR_CARPETA_RAIZ);
                                    
                                    ArrayList<String> listaCarpetas = new ArrayList<String>();
                                    listaCarpetas.add(carpetaRaiz);
                                    listaCarpetas.add(codOrganizacion + ConstantesDatos.GUION + descripcionOrganizacion);
                                    listaCarpetas.add(codUnidadRegistro + ConstantesDatos.GUION + descripcionUnidadRegistro);
                                    
                                    if(regESVO.getTipoReg().equalsIgnoreCase("E"))
                                        listaCarpetas.add(ConstantesDatos.DESCRIPCION_ENTRADAS_REGISTRO);
                                    else
                                    if(regESVO.getTipoReg().equalsIgnoreCase("S"))
                                        listaCarpetas.add(ConstantesDatos.DESCRIPCION_SALIDAS_REGISTRO);    

                                    listaCarpetas.add(regESVO.getAnoReg() + ConstantesDatos.GUION + regESVO.getNumReg());
                                    datos.put("listaCarpetas",listaCarpetas);
                                }
                                
                                Documento docReg = DocumentoTramitacionFactoria.getInstance().getDocumento(datos, tipoDocumento);                                
                                rutasDocumentosNuevos.add(regDoc.getRutaDocumentoRegistroDisco());
                                docsRegistroNuevos.add(docReg);                                
                                                             
                            }else
                            if(regDoc.getEstadoDocumentoRegistro()==ConstantesDatos.ESTADO_DOCUMENTO_ELIMINADO){
                                
                                Hashtable<String,Object> datos = new Hashtable<String,Object>();
                                datos.put("identDepart",new Integer(regESVO.getIdentDepart()));
                                datos.put("unidadOrgan",new Integer(regESVO.getUnidadOrgan()));
                                datos.put("anoReg",new Integer(regESVO.getAnoReg()));
                                datos.put("numReg",new Long(regVO.getNumReg()));
                                datos.put("tipoReg",regESVO.getTipoReg());
                                datos.put("nombreDocumento",regDoc.getNombreDoc());
                                datos.put("tipoDoc",regDoc.getTipoDoc());    
                                datos.put("idDocumento",new Long(regDoc.getIdDocumento()));
                                if(regDoc.getFechaDoc()!=null) datos.put("fechaDoc",regDoc.getFechaDoc());
                                datos.put("entregado",regDoc.getEntregado());
                                datos.put("documentoRegistro",new Boolean(true));
                                datos.put("params",params);
                                datos.put("codMunicipio",Integer.toString(codOrganizacion));
                                datos.put("tipoMime",regDoc.getTipoDoc());
                                datos.put("extension", MimeTypes.guessExtensionFromMimeType(regDoc.getTipoDoc()));
                                
                                
                                datos.put("estadoDocumentoRegistro",regDoc.getEstadoDocumentoRegistro());
                                if(regDoc.getRutaDocumentoRegistroDisco()!=null)
                                    datos.put("rutaDocumento",regDoc.getRutaDocumentoRegistroDisco());
                                else
                                    datos.put("rutaDocumento","");
                                                                
                                // Metadatos del documento cotejo
                                rellenarMetadatosDocumentoCotejado(datos, regDoc);
                                
                                                                
                                if(almacen.isPluginGestor()){
                                    //  Si se trata de un plugin de un gestor documental, se pasa la información
                                    // extra necesaria                                    
                                    ResourceBundle config = ResourceBundle.getBundle("documentos");                            
                                    String carpetaRaiz    = config.getString(ConstantesDatos.PREFIJO_PROPIEDAD_ALMACENAMIENTO + codOrganizacion + ConstantesDatos.BARRA + almacen.getNombreServicio() + ConstantesDatos.SUFIJO_PLUGIN_GESTOR_CARPETA_RAIZ);
                                                                        
                                    ArrayList<String> listaCarpetas = new ArrayList<String>();
                                    listaCarpetas.add(carpetaRaiz);
                                    listaCarpetas.add(codOrganizacion + ConstantesDatos.GUION + descripcionOrganizacion);
                                    listaCarpetas.add(codUnidadRegistro + ConstantesDatos.GUION + descripcionUnidadRegistro);
                                    
                                    if(regESVO.getTipoReg().equalsIgnoreCase("E"))
                                        listaCarpetas.add(ConstantesDatos.DESCRIPCION_ENTRADAS_REGISTRO);
                                    else
                                    if(regESVO.getTipoReg().equalsIgnoreCase("S"))
                                        listaCarpetas.add(ConstantesDatos.DESCRIPCION_SALIDAS_REGISTRO);    

                                    listaCarpetas.add(regESVO.getAnoReg() + ConstantesDatos.GUION + regESVO.getNumReg());
                                    datos.put("listaCarpetas",listaCarpetas);
                                }
                                
                                Documento docReg = DocumentoTramitacionFactoria.getInstance().getDocumento(datos, tipoDocumento);                                
                                docsRegistroEliminados.add(docReg);                                
                            }
                        }

                        try{
                            
                            //Se eliminan los metadatos de los documentos
                            eliminarMetadatosDocumentosCatalogados(docsRegistroEliminados, con);
                            
                            // Elimina los documentos marcados como eliminados, bien del disco o bien del gestor
                            eliminarDocumentos(almacen,docsRegistroEliminados,con);
                            
                            // Se dan de alta los documentos nuevos
                            almacen.setDocumentosRegistro(docsRegistroNuevos,con);
                            
                            // Se procede a eliminar los ficheros nuevos de la anotación que residen en el disco del servidor
                            eliminarDocumentosRegistroNuevosServidor(rutasDocumentosNuevos);
                            
                            //Se vuelven a dar de alta los metadatos de los documentos que se han modificado 
                            insertMetadatosDocumentosModificados(metadatosDocumentosModificados, con);
                        
                        }catch(AlmacenDocumentoTramitacionException e){
                            throw new AnotacionRegistroException(e.getMessage());
                        }catch(Exception e){
                            throw new AnotacionRegistroException(e.getMessage());
                        }
                         
                     }
                   
                } else {
                    SigpGeneralOperations.rollBack(oad, con);
                }

           }   
           
           SigpGeneralOperations.commit(oad, con);            
            
           m_Log.debug("Registro modificado correctamente");
           
           m_Log.debug("modify");

        } catch (BDException bde) {
            SigpGeneralOperations.rollBack(oad, con);
            Logger.getLogger(AnotacionRegistroDAO.class.getName()).log(Level.SEVERE, null, bde);
            throw new AnotacionRegistroException(m_ConfigError.getString("Error.AnotacionRegistroDAO.modificacionDatosRegistro"), bde);
        } catch (Exception e) {
            SigpGeneralOperations.rollBack(oad, con);            
            Logger.getLogger(AnotacionRegistroDAO.class.getName()).log(Level.SEVERE, null, e);
            throw new AnotacionRegistroException(m_ConfigError.getString("Error.AnotacionRegistroDAO.modificacionDatosRegistro"), e);
       }finally{
            SigpGeneralOperations.devolverConexion(oad, con);
        }
    }
    
    private void eliminarEntregadosAnterior(ArrayList<RegistroValueObject> docs, Connection con){
        for(int i=0; docs!=null && i<docs.size(); i++){
            RegistroValueObject docAnt=docs.get(i);
            m_Log.debug("====>Eliminando Doc Entregado Anterior");
            try{                   
            AnotacionRegistroDAO.getInstance().eliminarEntregadosAnterior(docAnt,con);       
        }catch(Exception e){
           m_Log.error("No se ha podido eliminar documento: "  + e.getMessage());
        }
        }
    }
    
    private void modificarEntregadosAnterior(ArrayList<RegistroValueObject> docs, Connection con){
        for(int i=0; docs!=null && i<docs.size(); i++){
            RegistroValueObject docAnt=docs.get(i);
            m_Log.debug("====>Modificando Doc Entregado Anterior");
            try{
                AnotacionRegistroDAO.getInstance().modificarEntregadosAnterior(docAnt,con);
            }catch(Exception e){
                m_Log.error("No se ha podido modificar documento: "+ e.getMessage());
            }
        }
    }
    
    private boolean eliminarDocumentos(AlmacenDocumento almacen,ArrayList<Documento> documentos,Connection con) throws AlmacenDocumentoTramitacionException{
        boolean exito = false;
        
        for(int i=0;documentos!=null && i<documentos.size();i++){
            Documento doc = documentos.get(i);
            
            
            m_Log.debug("eliminarDocumentos estadoDocumentoRegistro: " + doc.getEstadoDocumentoRegistro());
            m_Log.debug("eliminarDocumentos rutaDocumento: " + doc.getRutaDocumento());
            m_Log.debug("==========>");
            if(doc.getEstadoDocumentoRegistro().intValue()==ConstantesDatos.ESTADO_DOCUMENTO_ELIMINADO && 
                    doc.getRutaDocumento()!=null && !"".equals(doc.getRutaDocumento())){
                // Han sido eliminado de la lista de ficheros de la anotación y no han sido grabado, así que
                // se eliminan del directorio temporal en disco
                
                try{
                    FileOperations.deleteFile(doc.getRutaDocumento());
                }catch(Exception e){
                    m_Log.error("No se ha podido eliminar el fichero de la ruta: " + doc.getRutaDocumento() + ": " + e.getMessage());
                }
                
            }else
            if(doc.getEstadoDocumentoRegistro().intValue()==ConstantesDatos.ESTADO_DOCUMENTO_ELIMINADO &&
                   "".equals(doc.getRutaDocumento())){
                
                
                // Se invoca al método que elimina el documento del plugin de almacenamiento correspondiente
                try{
                    if(!almacen.eliminarDocumentoRegistro(doc,con)){
                        throw new AlmacenDocumentoTramitacionException(4,"Error al eliminar el documento " + doc.getNombreDocumento() + " correspondiente a la anotación " + doc.getEjercicioAnotacion() + "-" + doc.getNumeroRegistro());
                    }
                    
                }catch(AlmacenDocumentoTramitacionException e){
                    // Si al tratar de eliminar un documento de algún repositorio de documentación, se propaga
                    // la excepción, para cancelar la operación y deshacer los cambios realizados en base de datos
                    m_Log.error("Error al eliminar un documento de registro a través del plugin: " + e.getMessage());
                    e.printStackTrace();
                    throw e;
                }
                
            }
        }
        
        return exito;
    }
    
    
    private boolean eliminarDocumentosRegistroNuevosServidor(ArrayList<String> rutas){
        boolean exito = false;
        
        try{
            for(int i=0;rutas!=null && i<rutas.size();i++){
                if(rutas.get(i)!=null){
                    FileOperations.deleteFile(rutas.get(i));
                }
            }
            
        }catch(Exception e){
            m_Log.error("Error al eliminar archivos de disco y que se han asociado a una anotación de registro: " + e.getMessage());
            e.printStackTrace();
        }
        return exito;
    }
    

    public String[] siguiente(RegistroValueObject registro, String[] params)
            throws AnotacionRegistroException {        

        try {

            m_Log.debug("Usando persistencia manual");
            m_Log.debug("En el siguiente del manager***********************");
            String[] salida = AnotacionRegistroDAO.getInstance().loadSiguienteRER(registro, params);
            m_Log.debug("Tipos de Actuaciones obtenidos");
            //We want to be informed when this method has finalized
            m_Log.debug("siguiente termina");
            return salida;

        } catch (Exception ce) {
            ce.printStackTrace();
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }
    }


    public void anular(RegistroValueObject registro,boolean digitalizacion, String[] params)
            throws AnotacionRegistroException {

        m_Log.debug("anular");

        try {

            m_Log.debug("Usando persistencia manual");
            AnotacionRegistroDAO.getInstance().anular(registro,digitalizacion, params);
            m_Log.debug("Tipos de Actuaciones obtenidos");
            //We want to be informed when this method has finalized
            m_Log.debug("anular");

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }
    }

    public Vector getListaTiposIdInteresado(String[] params)
            throws AnotacionRegistroException {

        Vector res;
        m_Log.debug("getListaTiposIdentificadoresInteresado");

        try {
            m_Log.debug("Usando persistencia manual");
            res = AnotacionRegistroDAO.getInstance().getListaTiposIdInteresado(params);
            m_Log.debug("Tipos identificadores de interesado obtenidos");
            //We want to be informed when this method has finalized
            m_Log.debug("getListaTiposIdentificadoresInteresado");
        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }
        return res;
    }


    public String getIndicadorPersonaFisicaJuridica(String tipoDoc, String[] params) throws AnotacionRegistroException {
        try {
            return AnotacionRegistroDAO.getInstance().getIndicadorPersonaFisicaJuridica(tipoDoc, params);
        } catch (TechnicalException te) {
            m_Log.error("JDBC Technical problem " + te.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + te.getMessage());
        }
    }

    /* *******************************************************************************************************
   Relación de anotaciones.
   ****************************************************************************************************** */
    public Vector relacionRegistroValueObject(RegistroValueObject patron, String[] params, int startIndex, int count,int columna,String tipoOrden)
            throws AnotacionRegistroException {

        Vector res;
        //queremos estar informados de cuando este metodo es ejecutado
        m_Log.debug("relacionRegistroValueObject");


        try {
            m_Log.debug("Usando persistencia manual");

            res = AnotacionRegistroDAO.getInstance().relacionRegistroValueObject(patron, params, startIndex, count,columna,tipoOrden);

            m_Log.debug("Relación de registros value objects obtenidos");
            //We want to be informed when this method has finalized
            m_Log.debug("relacionRegistroValueObject");

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());

        }
        return res; 
    }
    
    public ArrayList relacionCampoRegistroValueObject(RegistroValueObject patron, String campo, String[] params) throws AnotacionRegistroException {
        //queremos estar informados de cuando este metodo es ejecutado
        m_Log.info("relacionCampoRegistroValueObject()::BEGIN");

        ArrayList res;
        try {
            m_Log.debug("Usando persistencia manual");

            res = AnotacionRegistroDAO.getInstance().relacionCampoRegistroValueObject(patron, campo, params);

            m_Log.debug("Relación de registros value objects con datos de oficina de registro obtenidos");
            //We want to be informed when this method has finalized
            m_Log.info("relacionCampoRegistroValueObject()::END");

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());

        }
        return res; 
    }
    
    
     public ArrayList<Vector> relacionRegistroValueObjectImprimirOptimo(RegistroValueObject patron, String[] params, int startIndex, int count,int columna,String tipoOrden)
            throws AnotacionRegistroException {

         ArrayList<Vector> res = new ArrayList<Vector>();
        //queremos estar informados de cuando este metodo es ejecutado
        m_Log.debug("relacionRegistroValueObjectImprimirOptimo");


        try {
            m_Log.debug("Usando persistencia manual");

            res = AnotacionRegistroDAO.getInstance().relacionRegistroValueObjectImprimirOptimo(patron, params, startIndex, count,columna,tipoOrden);

            m_Log.debug("Relación de registros value objects obtenidos");
            //We want to be informed when this method has finalized
            m_Log.debug("relacionRegistroValueObjectImprimirOptimo");

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());

        }
        return res;
    }
    /* ********************************************************************************************************
     * Recoge los campos de listado de anotaciones que existen en la bbdd
     * ****************************************************************************************************** */
    public Vector getCamposListado(int codListado, String[] params) throws AnotacionRegistroException {

         try {
            m_Log.debug("Usando persistencia manual");
            return AnotacionRegistroDAO.getInstance().getCamposListado(codListado, params);

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }
    }
    /* ********************************************************************************************************
     * Numero de Relación de anotaciones.
     * ****************************************************************************************************** */
    public int getNumeroTotalAnotaciones(RegistroValueObject patron, String[] params) throws AnotacionRegistroException {

         try {
            m_Log.debug("Usando persistencia manual");
            return AnotacionRegistroDAO.getInstance().getNumeroTotalAnotaciones(patron, params);

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }
    }

    /**
     * Comprueba la existencia de un asiento.
     * @param reg SimpleRegistroValueObject con la clave del asiento.
     * @param params Parametros de conexión a BD.
     * @return true si existe el asiento, false en caso contrario
     */
    public boolean existeAsiento(SimpleRegistroValueObject reg, String[] params) throws AnotacionRegistroException {
        try {
            m_Log.debug("Usando persistencia manual");
            return AnotacionRegistroDAO.getInstance().existeAsiento(reg, params);

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        }
    }

    /**
     * Inserta los datos de una anotacion en BD. No inserta los interesados,
     * temas, relaciones ni documentos.
     * @param oad adaptador BD
     * @param con conexion
     * @param reg vo con los datos
     * @throws es.altia.agora.business.registro.exception.AnotacionRegistroException
     */
    public void insertarAnotacion(AdaptadorSQLBD oad, Connection con, RegistroValueObject reg) throws Exception {
        try {
            AnotacionRegistroDAO.getInstance().insertarAnotacion(oad, con, reg);

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw ce;
        }
    }
    
    /**
     * Inserta los datos de los interesados de una anotacion en BD.
     * @param con conexion
     * @param reg vo con los datos de los interesados (codigos)
     * @throws es.altia.agora.business.registro.exception.AnotacionRegistroException
     */
    public void insertarInteresados(Connection con, RegistroValueObject reg) throws Exception {
        try {
            AnotacionRegistroDAO.getInstance().insertarInteresados(con, reg);

        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw ce;
        }        
    }


    /**
     * Recupera un documento determinado perteneciente a una anotación
     * @param reg SimpleRegistroValueObject con la clave del asiento.
     * @param params Parametros de conexión a BD.
     * @return true si existe el asiento, false en caso contrario
     */
    public DocumentoValueObject getDocumento(RegistroValueObject reg, String[] params) throws AnotacionRegistroException {
        AdaptadorSQLBD abd = null;
        Connection con = null;
        
        DocumentoValueObject doc = null;
                
        try {    
            abd = new AdaptadorSQLBD(params);
            con = abd.getConnection();

            doc = AnotacionRegistroDAO.getInstance().getDocumento(reg, con);
        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ce.getMessage());
        } finally {
            try {
                SigpGeneralOperations.devolverConexion(abd, con);
            } catch (TechnicalException te) {
                m_Log.error("JDBC Technical problem " + te.getMessage());
                throw new AnotacionRegistroException("Problema técnico de JDBC " + te.getMessage());
        }
    }

        return doc;
    }

    public Vector<RegistroValueObject> getListaDocumentos(RegistroValueObject registro, String[] params) throws AnotacionRegistroException {
        Vector<RegistroValueObject> docs = null;
        AdaptadorSQLBD abd = null;
        Connection con = null;
        
        try {
            abd = new AdaptadorSQLBD(params);
            con = abd.getConnection();
            
            docs = AnotacionRegistroDAO.getInstance().getListaDocumentos(registro, con);
        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem " + ce);
            docs = null;
        } finally {
            try {
                SigpGeneralOperations.devolverConexion(abd, con);
            } catch (Exception ce) {
                m_Log.error("JDBC Technical problem " + ce);
                docs = null;
            }
        }

        return docs;
    }
    

    /**
     *  Obtiene la lista de los registros que tienen asociado un determinado asunto.
     *
     * @param asunto El MantAsuntosValueObject que representa el asunto.
     * @param params Informacion de la conexión a la BD.
     * @return Vector con los registros que tienen asociado un determinado asunto.
     */
    public Vector<RegistroValueObject> getListaRegistrosPorAsunto(MantAsuntosValueObject asunto,String[] params){
        Vector<RegistroValueObject> registrosAsunto = new Vector<RegistroValueObject>();

        try {
            registrosAsunto = AnotacionRegistroDAO.getInstance().getListaRegistrosPorAsunto(asunto, params);
        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem in getListaRegistrosPorAsunto" + ce.getMessage());
            ce.printStackTrace();
        }
        return registrosAsunto;
    }


     /**
     *  Modifica el asunto de un determinado registro.
     *
     * @param registroValueObject RegistroValueObject que se va actualizar.
     * @param conexion Conexión a la BD con transacción abierta.
     */
    public void modificarAsuntoRegistro( RegistroValueObject registroValueObject, Connection conexion){       

        try {
            AnotacionRegistroDAO.getInstance().modificarAsuntoRegistro(registroValueObject, conexion);
        } catch (Exception ce) {
            m_Log.error("JDBC Technical problem in modificarAsuntoRegistro" + ce.getMessage());
            ce.printStackTrace();
        }
    }


    /**
     * Factory method para el <code>Singelton</code>.
     *
     * @return La unica instancia de SelectManager
     */
    public static AnotacionRegistroManager getInstance() {
        //Si no hay una instancia de esta clase tenemos que crear una
        if (instance == null) {
            // Necesitamos sincronización aquí para serializar (no multithread)
            // las invocaciones a este metodo
            synchronized (AnotacionRegistroManager.class) {
                if (instance == null) {
                    instance = new AnotacionRegistroManager();
                }
            }
        }
        return instance;
    }

    private static AnotacionRegistroManager instance = null; // Mi propia instancia usada en el metodo getInstance

    /*
     * Declaracion de servicios
     */

    protected static Config m_ConfigTechnical; // Para el fichero de configuracion technical
    protected static Config m_ConfigError; // Para el fichero de mensajes de error localizados
    protected static Log m_Log =
            LogFactory.getLog(AnotacionRegistroManager.class.getName());


    /** oscar **/
      public GeneralValueObject getAnotacionMasAntigua(String numeroExpediente, String[] params)
            throws AnotacionRegistroException {
            AdaptadorSQLBD adapt = new AdaptadorSQLBD(params);
            Connection con = null;
            try{
                con = adapt.getConnection();
                return AnotacionRegistroDAO.getInstance().getAnotacionMasAntigua(numeroExpediente, con);
            }catch(Exception e){
                e.printStackTrace();
                m_Log.error(this.getClass().getName() + ".getAnotacionMasAntigua: " + e.getMessage());
                throw new AnotacionRegistroException(e.getMessage());
            }finally{
                try{
                    if(con!=null) con.close();
                }catch(SQLException e){
                    e.printStackTrace();
                    m_Log.error(this.getClass().getName() + ".getAnotacionMasAntigua: " + e.getMessage());
                }
            }
      }

     /**
     * Método auxiliar que te devuelve un nombre de oficina, para la funcionalidad
     * imprimirCuneus
     * @param codigoOficina codigo de la oficina, de la que queremos obtener el nombre
     * @param params info para acceder a la BD
     * @return String nombre de la oficina
     * @throws AnotacionRegistroException
     * @throws TechnicalException
     */
    public String dameNombreOficina(int codigoOficina, String[] params)
         {
         
         String nombreOficina="";
            try{
                    nombreOficina= AnotacionRegistroDAO.getInstance().dameNombreOficina(codigoOficina, params);
             
            }catch (Exception ce) {
                 m_Log.error("JDBC Technical problem in getListaRegistrosPorAsunto" + ce.getMessage());
                ce.printStackTrace();
            }
      
            return nombreOficina;
    }
 
     
     /**
     * Método auxiliar que te devuelve un nombre de oficina, para la funcionalidad
     * imprimirCuneus
     * @param codUor codigo de la unidad órganica
     * @param codAnotacion codigo de la anotación 
     * @param resEje ejercicio de la anotacion
     * @param tipoReg tipo de la Anotacion (E->entrada/S->salida)
     * @return codigo Codigo de la oficina
     * @throws AnotacionRegistroException
     * @throws TechnicalException
     */
    public int dameCodigoOficina(int codUor,long codAnotacion,int resEje,String tipoReg, String[] params)
         {
            int codigoOficina=-99498;
            try{
            
                    codigoOficina= AnotacionRegistroDAO.getInstance().dameCodigoOficina(codUor,codAnotacion,resEje,tipoReg, params);
             
            }catch (Exception ce) {
                 m_Log.error("JDBC Technical problem in getListaRegistrosPorAsunto" + ce.getMessage());
                ce.printStackTrace();
            }
      
            return codigoOficina;
    }
    
    
    
    /**
     * Recupera un documento determinado asociado a una determinada anotaciones de registro
     * @param doc: Objeto de tipo DocumentoAnotacionRegistroVO
     * @param params: Parámetros de conexión a la BBDD
     * @return Objeto de tipo DocumentoAntacionRegistroVO
     */
     public DocumentoAnotacionRegistroVO getDocumentoAnotacionRegistro(DocumentoAnotacionRegistroVO doc,String[] params){
         AdaptadorSQLBD adapt = null;
         Connection con = null;
         
         try{
             adapt = new AdaptadorSQLBD(params);
             con   = adapt.getConnection();
             
             AnotacionRegistroDAO.getInstance().getDocumentoAnotacionRegistro(doc, con);
             
         }catch(BDException e){
             m_Log.error(this.getClass().getName() + " - ERROR al recuperar una conexión a la BBDD: " + e.getMessage());
             
         }finally{
             try{
                 if(con!=null) con.close();
                 
             }catch(SQLException e){
                 m_Log.error(this.getClass().getName() + " - ERROR al cerrar conexión a la BBDD: " + e.getMessage());
             }
         }         
         return doc;         
     }

     
       /**
      * Obtiene un documento con el fichero asociado. Dependiendo de donde este
      * alojado lo obtendra del Servidor o del tipo de gestor configurado
      * (BBDD o Alfresco).
      * 
      * @param doc Documento que contendra los datos necesarios para poder obtener el fichero
      * @param usuario Usuario que invoca este metodo
      * @return 
      */
     public Documento getDocumentoFichero(RegistroValueObject doc, UsuarioValueObject usuario) {
        Documento documento = null;

        if(doc!=null){
            if (doc.getEstadoDocumentoRegistro() == ConstantesDatos.ESTADO_DOCUMENTO_NUEVO && doc.getRutaDocumentoRegistroDisco() != null) {
                // No se ha confirmado todavía la grabación del documento en el repositorio de documentación, 
                // que bien puede ser la base de datos o algún gestor documental, por tanto, para poder 
                // visualizar su contenido habrá que leer el fichero del disco

                // Se recupera la ruta del fichero en el disco del servidor
                String pathFile = doc.getRutaDocumentoRegistroDisco();
                
                m_Log.debug("de la carpeta temporal pathFile "+pathFile);

                try {
                    File f = new File(pathFile);

                    documento = new DocumentoBBDD();
                    documento.setFichero(FileOperations.readFile(f));
                    documento.setTipoMimeContenido(doc.getTipoDoc());
                    documento.setNombreDocumento(doc.getNombreDoc());
                    documento.setExtension(MimeTypes.guessExtensionFromMimeType(doc.getTipoDoc()));
                } catch (Exception e) {
                    m_Log.error(e.getMessage(), e);
                    e.printStackTrace();
                }

            } else if (doc.getEstadoDocumentoRegistro() == ConstantesDatos.ESTADO_DOCUMENTO_GRABADO) {

                        // Si el documento ya ha sido grabado con anterioridad, entonces habrá que invocar al 
                // plugin correspondiente para descargar su contenido
                String[] params = usuario.getParamsCon();
                AlmacenDocumento almacen = AlmacenDocumentoTramitacionFactoria.getInstance(Integer.toString(usuario.getOrgCod())).getImplClassRegistro(Integer.toString(usuario.getOrgCod()));
                int codOrganizacion = usuario.getOrgCod();
                int codUnidadRegistro = doc.getUnidadOrgan();
     
                Hashtable<String, Object> datos = new Hashtable<String, Object>();
                datos.put("identDepart", new Integer(doc.getDptoUsuarioQRegistra()));
                datos.put("unidadOrgan", new Integer(doc.getUnidadOrgan()));
                datos.put("anoReg", new Integer(doc.getAnoReg()));
                datos.put("numReg", new Long(doc.getNumReg()));
                datos.put("tipoReg", doc.getTipoReg());
                datos.put("nombreDocumento", doc.getNombreDoc());
                datos.put("documentoRegistro", new Boolean(true));
                datos.put("params", params);

                int tipoDocumento = -1;
                if (!almacen.isPluginGestor()) {
                    tipoDocumento = DocumentoTramitacionFactoria.TIPO_DOCUMENTO_BBDD;
                } else {
                    tipoDocumento = DocumentoTramitacionFactoria.TIPO_DOCUMENTO_GESTOR;
                    datos.put("codMunicipio", Integer.toString(codOrganizacion));
                    datos.put("tipoMime", doc.getTipoDoc());
                    datos.put("extension", MimeTypes.guessExtensionFromMimeType(doc.getTipoDoc()));

                    if (almacen.isPluginGestor()) {
                                //  Si se trata de un plugin de un gestor documental, se pasa la información
                        // extra necesaria                                    
                        ResourceBundle config = ResourceBundle.getBundle("documentos");
                        /**
                         * String tipoPlugin =
                         * config.getString(ConstantesDatos.PROPIEDAD_PLUGIN_ALMACENAMIENTO);
                         * String nombreGestor =
                         * config.getString(ConstantesDatos.PREFIJO_PROPIEDAD_ALMACENAMIENTO
                         * + codOrganizacion + ConstantesDatos.BARRA + tipoPlugin +
                         * ConstantesDatos.SUFIJO_PLUGIN_NOMBRE_GESTOR); String
                         * carpetaRaiz =
                         * config.getString(ConstantesDatos.PREFIJO_PROPIEDAD_ALMACENAMIENTO
                         * + codOrganizacion + ConstantesDatos.BARRA + nombreGestor
                         * + ConstantesDatos.SUFIJO_PLUGIN_GESTOR_CARPETA_RAIZ);
                         */
                        String carpetaRaiz = config.getString(ConstantesDatos.PREFIJO_PROPIEDAD_ALMACENAMIENTO + codOrganizacion + ConstantesDatos.BARRA + almacen.getNombreServicio() + ConstantesDatos.SUFIJO_PLUGIN_GESTOR_CARPETA_RAIZ);

                        Connection con = null;
                        String descripcionOrganizacion = null;
                        String descripcionUnidadRegistro = null;
                        AdaptadorSQLBD adapt = null;
                        try {
                            adapt = new AdaptadorSQLBD(params);
                            con = adapt.getConnection();

                            descripcionOrganizacion = OrganizacionesDAO.getInstance().getDescripcionOrganizacion(codOrganizacion, con);
                            //descripcionUnidadRegistro = UORsDAO.getInstance().getDescripcionUOR(codOrganizacion,con);
                            UORDTO uorDTO = (UORDTO) CacheDatosFactoria.getImplUnidadesOrganicas().getDatoClaveUnica(params[6], String.valueOf(codUnidadRegistro));
                            if (uorDTO != null) {
                                descripcionUnidadRegistro = uorDTO.getUor_nom();
                            }

                        } catch (BDException e) {
                            m_Log.error("Error al recuperar una conexión a la BBDD: " + e.getMessage());
                        } finally {
                            try {
                                adapt.devolverConexion(con);
                            } catch (BDException e) {
                                m_Log.error("Error al cerrar la conexión a la BBDD: " + e.getMessage());
                            }
                        }

                        ArrayList<String> listaCarpetas = new ArrayList<String>();
                        listaCarpetas.add(carpetaRaiz);
                        listaCarpetas.add(codOrganizacion + ConstantesDatos.GUION + descripcionOrganizacion);
                        listaCarpetas.add(codUnidadRegistro + ConstantesDatos.GUION + descripcionUnidadRegistro);

                        if (doc.getTipoReg().equalsIgnoreCase("E")) {
                            listaCarpetas.add(ConstantesDatos.DESCRIPCION_ENTRADAS_REGISTRO);
                        } else if (doc.getTipoReg().equalsIgnoreCase("S")) {
                            listaCarpetas.add(ConstantesDatos.DESCRIPCION_SALIDAS_REGISTRO);
                        }

                        listaCarpetas.add(doc.getAnoReg() + ConstantesDatos.GUION + doc.getNumReg());
                        datos.put("listaCarpetas", listaCarpetas);
                    }
                }

                try {
                    documento = DocumentoTramitacionFactoria.getInstance().getDocumento(datos, tipoDocumento);
                    documento = almacen.getDocumentoRegistro(documento);
                    documento.setExtension(MimeTypes.guessExtensionFromMimeType(documento.getTipoMimeContenido()));
                     m_Log.debug("desde BBDD   "+documento.getNombreDocumento());
                } catch (AlmacenDocumentoTramitacionException e) {
                    m_Log.error(e.getMessage(), e);
                    e.printStackTrace();
                }
            }
        }

        return documento;
    }
     
     
     /**
      * Método llamado para duplicar una anotación de registro y los documentos asociados 
      * a la misma
      * @param regESVO: Objeto de la clase RegistroValueObject con los datos de la anotación a dar
      * de alta
      * @param params: Parámetros de conexión a la BBDD
      * @throws AnotacionRegistroException
      * @throws TechnicalException 
      */
    public void duplicar(RegistroValueObject regESVO, String[] params)
            throws AnotacionRegistroException, TechnicalException {
        
        RegistroValueObject regVO = null;
        Connection con = null;
        AdaptadorSQLBD oad = null;       
      
        try {

            oad = new AdaptadorSQLBD(params);
            con = oad.getConnection();
            oad.inicioTransaccion(con);
            
            /*** PRUEBA ****/
            int ejercicioAnotacionOriginal = 0;
            long numeroRegistroOriginal    = 0;
            String tipoAnotacionOrigen = null;
            String infoAnotacionOriginal = "";
                        
            Vector<SimpleRegistroValueObject> relaciones = regESVO.getRelaciones();
            if(relaciones!=null && relaciones.size()>=1){
                // Si se contesta una anotación, en relaciones está la anotación contestada, que es de entrada
                tipoAnotacionOrigen = relaciones.get(0).getTipo();
                ejercicioAnotacionOriginal = Integer.parseInt(relaciones.get(0).getEjercicio());
                numeroRegistroOriginal = new Long(relaciones.get(0).getNumero());  
                infoAnotacionOriginal = "Anotacion contestada: ";
            }else{
                // Si no hay relaciones, entonces se está duplicando la anotación, sea de entrada o de salida
                tipoAnotacionOrigen = regESVO.getTipoReg();
                ejercicioAnotacionOriginal = regESVO.getEjercicioAnotacionDuplicadaOrigen();
                numeroRegistroOriginal    = regESVO.getNumReg();  
                infoAnotacionOriginal = "Anotacion duplicada: ";
            }
            infoAnotacionOriginal += "(" + tipoAnotacionOrigen + ") " + ejercicioAnotacionOriginal + "/" + numeroRegistroOriginal;
            m_Log.info("duplicar() ----> " + infoAnotacionOriginal);
            
            
            /** ORIGINAL
            int ejercicioAnotacionOriginal = regESVO.getEjercicioAnotacionDuplicadaOrigen();
            long numeroRegistroOriginal    = regESVO.getNumReg();
            **/
			
			regVO = AnotacionRegistroDAO.getInstance().insertRegistroValueObject(con, regESVO, params);
            
            int ejercicioAnotacionDuplicada = regVO.getAnoReg();
            long numeroRegistroDuplicado = regVO.getNumReg();
            String tipoAnotacionDestino = regVO.getTipoReg();
            if (regVO != null && regVO.getNumReg() > 0){
            
                if (("registrar_alta_entrada_denegada".equals(regVO.getRespOpcion())) || ("actualizacion_ya_realizada".equals(regVO.getRespOpcion())) ||
                        ("registrar_alta_sin_confirmar".equals(regVO.getRespOpcion())) || ("no_existe_expediente".equals(regVO.getRespOpcion()))) {
                    SigpGeneralOperations.rollBack(oad, con);
                } else{

                    Vector docs = regESVO.getListaDocsAsignados();

                    //Inserta los documentos asociados el registro
                    if (docs != null && docs.size() >0 && regVO.getRespOpcion().equals("registrar_alta_entrada_aceptada")){
                        //ESTA OPCION ES SOLO PARA LANBIDE, HABRA QUE ANHADIR UN PROPERTY SI SE LLEVA A OTROS CLIENTES                        
                        //Forzamos a que el plugin de almacen sea el de BBDD porque no queremos que los documentos en Dokusi se dupliquen, solo necesitan que se copie la referencia al documento
                        //en la tabla R_RED tanto que este almacenado en BBDD y tenga blob como que este en DOKUSI y tenga OID.
                        Class implClass = Class.forName("es.altia.agora.business.sge.plugin.documentos.AlmacenDocumentoBBDDImpl");
                        AlmacenDocumento almacen = (AlmacenDocumento)implClass.newInstance();
                        
                        int tipoDocumento = -1;
                        String descripcionOrganizacion = null;
                        String descripcionUnidadRegistro = null;
                        
                        //Plugin BBDDD
                        tipoDocumento = DocumentoTramitacionFactoria.TIPO_DOCUMENTO_BBDD;
                        
                        ArrayList<Documento> docsRegistroNuevos = new ArrayList<Documento>();                                               
                        int codOrganizacion = regESVO.getIdOrganizacion();                        
                        int codUnidadRegistro = Integer.parseInt(regESVO.getUnidOrgUsuarioQRegistra());                        
                        
                        for (int i = 0; i < docs.size(); i++) {
                            RegistroValueObject regDoc = (RegistroValueObject) docs.elementAt(i);
                                                                
                            Hashtable<String,Object> datos = new Hashtable<String,Object>();
                            datos.put("identDepart",new Integer(regESVO.getIdentDepart()));
                            datos.put("unidadOrgan",new Integer(regESVO.getUnidadOrgan()));

                            datos.put("anoReg",ejercicioAnotacionOriginal);
                            datos.put("numReg",new Long(numeroRegistroOriginal));
                            //datos.put("tipoReg",regESVO.getTipoReg());
                            datos.put("tipoReg",tipoAnotacionOrigen);
                            datos.put("nombreDocumento",regDoc.getNombreDoc());
                            datos.put("tipoDoc",regDoc.getTipoDoc());                                
                            if(regDoc.getFechaDoc() != null){
                                datos.put("fechaDoc",regDoc.getFechaDoc());
                            }
                            datos.put("entregado",regDoc.getEntregado());
                            datos.put("documentoRegistro",new Boolean(true));                                
                            datos.put("params",params);
                            datos.put("codMunicipio",Integer.toString(codOrganizacion));
                            datos.put("tipoMime",regDoc.getTipoDoc());
                            datos.put("extension", MimeTypes.guessExtensionFromMimeType(regDoc.getTipoDoc()));
                            if (regDoc.getDoc()!=null)
                                datos.put("fichero", regDoc.getDoc());

                            // Metadatos del documento cotejo
                            rellenarMetadatosDocumentoCotejado(datos, regDoc);

                            Documento docReg = DocumentoTramitacionFactoria.getInstance().getDocumento(datos, tipoDocumento);                                                                
                            docsRegistroNuevos.add(docReg);
                            
                        }// for

                        try{
                            
                            for(int i=0;docsRegistroNuevos!=null && i<docsRegistroNuevos.size();i++){
                                Documento doc = docsRegistroNuevos.get(i);                                
                   
                                if (doc.getFichero() == null) {
                                    try{
                                        doc = almacen.getDocumentoRegistro(doc);      
                                    }catch(Exception e){                                   
                                        // No se ha podido recuperar el contenido binario del documento, pero eso quiere decir que es documento de registro, pero 
                                        // sin binario. Este tipo de documento son los que se añaden a través de asuntos codificados, y no se sube el binario.
                                        m_Log.error("No se ha podido recuperar el contenido binario del documento de registro: " + e.getMessage());                                    
                                    }
                                }
                                                               
                                // Se indica el ejercicio, número y tipo de la anotación para la 
                                // que se dan de alta el documento
                                doc.setEjercicioAnotacion(ejercicioAnotacionDuplicada);
                                doc.setNumeroRegistro(numeroRegistroDuplicado);
                                doc.setTipoRegistro(tipoAnotacionDestino);

                                docsRegistroNuevos.set(i,doc);                            
                            }
                            
                            
                            almacen.setDocumentosRegistro(docsRegistroNuevos,con);
                             
                                                          
                         }catch(AlmacenDocumentoTramitacionException e){
                            e.printStackTrace();
                            // Si se ha producido un error al insertar los documentos, hay que lanzar 
                            //  una AnotacionRegistroException para deshacer los cambios realizados en la BBDD
                            throw new AnotacionRegistroException(e.getMessage());
                         }
                    }
                }
            }
            
            SigpGeneralOperations.commit(oad, con);                        
            m_Log.debug("Registro insertado correctamente");
            m_Log.debug("insertRegistroValueObject");

        } catch (BDException bde) {
            SigpGeneralOperations.rollBack(oad, con);
            Logger.getLogger(AnotacionRegistroDAO.class.getName()).log(Level.SEVERE, null, bde);
            throw new AnotacionRegistroException(m_ConfigError.getString("Error.AnotacionRegistroDAO.insercionDatosRegistro"), bde);
        } catch (Exception e) {
            SigpGeneralOperations.rollBack(oad, con);            
            Logger.getLogger(AnotacionRegistroDAO.class.getName()).log(Level.SEVERE, null, e);
            throw new AnotacionRegistroException(m_ConfigError.getString("Error.AnotacionRegistroDAO.insercionDatosRegistro"), e);
       }finally{
            SigpGeneralOperations.devolverConexion(oad, con);
        }
    }
    
    public RegistroValueObject obtenerOficinaRegistro(RegistroValueObject registro, String[] params) throws AnotacionRegistroException{
        final int CODNOOFICINA = -55555;
        int codOfi = CODNOOFICINA;
        String nomOfi = null;
        
        try{
            codOfi = AnotacionRegistroDAO.getInstance().dameCodigoOficina(registro.getUnidadOrgan(), registro.getNumReg(), registro.getAnoReg(), registro.getTipoReg(), params);
            if(codOfi != CODNOOFICINA){
                nomOfi = AnotacionRegistroDAO.getInstance().dameNombreOficina(codOfi, params);
                registro.setCodOficinaRegistro(codOfi);
                registro.setNombreOficinaRegistro(nomOfi);
            }
            
        } catch (TechnicalException te){
            m_Log.error("Error al obtener una conexion a la base de datos");
            throw new AnotacionRegistroException("Error al obtener una conexion a la base de datos");
        } catch (AnotacionRegistroException ex) {
            m_Log.error("JDBC Technical problem " + ex.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + ex.getMessage());
        }
        
        return registro;
    }
    
     public String[] getDatosSga(RegistroValueObject registro, String[] params)throws AnotacionRegistroException{
        m_Log.debug("getDatosSga");
        String[] datosSga;
        AdaptadorSQLBD adapt=null;
        Connection con=null;
        try{
            adapt=new AdaptadorSQLBD(params);
            con=adapt.getConnection();
            datosSga=AnotacionRegistroDAO.getInstance().getDatosSga(registro, con);
            m_Log.debug("Datos Sga recuperados");
        } catch (BDException bde) {
            m_Log.error("Error al obtener una conexión a la BBDD.");
            throw new AnotacionRegistroException("Error al obtener una conexión a la BBDD.");
        }catch(Exception e){
           throw new AnotacionRegistroException(e.getMessage());
        } finally {
            try {
                if(con!=null) con.close();
            } catch (SQLException ex){
                m_Log.error("Error al cerrar la conexión a la BBDD");
            }
        }
        return datosSga;
    }
     
    /**
     * Envia un correo a la direccion de correo electronico indicada con el fichero
     * de documentacion
     * 
     * @param registro
     * @param usuario
     * @param indexFichero
     * @param emailDestinatario
     * @throws AnotacionRegistroException
     * @throws TechnicalException 
     */
    public void enviarCorreoDocumentoCotejo(RegistroValueObject registro, UsuarioValueObject usuario, Integer indexFichero, String emailDestinatario)
            throws AnotacionRegistroException, TechnicalException {

        Connection con = null;
        AdaptadorSQLBD oad = null;

        m_Log.debug("enviarCorreoDocumentoCotejo");
        try {
                // Historificar
                oad = new AdaptadorSQLBD(usuario.getParamsCon());
                con = oad.getConnection();
                oad.inicioTransaccion(con);

                // Obtenemos el fichero del documento
                RegistroValueObject doc = null;
                if (registro.getListaDocsAsignados() != null) {
                    doc = (RegistroValueObject) registro.getListaDocsAsignados().get(indexFichero);
                }
                
                ArrayList<Documento> listaDocumentos = new ArrayList<Documento>();
                Documento documento = AnotacionRegistroManager.getInstance().getDocumentoFichero(doc, usuario);
                listaDocumentos.add(documento);

                // Componemos el correo electronico
                String subject = m_ConfigTechnical.getString("mail.send.cotejo.subject");
                String content = m_ConfigTechnical.getString("mail.send.cotejo.content");
                content = content.replaceAll("@documento@", String.format("%s.%s", documento.getNombreDocumento(), documento.getExtension()));
                
                if (m_Log.isDebugEnabled()) {
                    m_Log.debug("EMAIL:");
                    m_Log.debug(String.format("subject: %s", subject));
                    m_Log.debug(String.format("content: %s", content));
                    m_Log.debug(String.format("nombreFichero: %s.%s", documento.getNombreDocumento(), documento.getExtension()));
                }
                
                // Datos para la historificacion de movimientos
                registro.setUsuarioQRegistra(String.valueOf(usuario.getIdUsuario()));
                registro.setDptoUsuarioQRegistra(String.valueOf(usuario.getDepCod()));
                registro.setUnidOrgUsuarioQRegistra(String.valueOf(usuario.getUnidadOrgCod()));
                
                // Obtenemos el xml que contiene el detalle del movimiento de historico
                HistoricoMailVO historicoMail = new HistoricoMailVO();
                historicoMail.setRazon(ConstantesDatos.HIST_ENVIO_CORREO_DOC_COTEJADO);
                historicoMail.setPara(Arrays.asList(emailDestinatario));
                String nombreFichero = String.format("%s.%s", documento.getNombreDocumento(), documento.getExtension());
                historicoMail.setFicherosAdjuntos(Arrays.asList(nombreFichero));
                historicoMail.setAsunto(subject);
                historicoMail.setContenido(content);
                String xmlMovimiento = HistoricoAnotacionHelper.crearXMLEnvioCorreo(historicoMail);

                // Creamos el objeto con los datos completos del movimiento
                HistoricoMovimientoValueObject hvo = new HistoricoMovimientoValueObject();
                hvo.setCodigoUsuario(Integer.parseInt(registro.getUsuarioQRegistra()));
                hvo.setTipoEntidad(ConstantesDatos.HIST_ENTIDAD_ANOTACION);
                hvo.setCodigoEntidad(HistoricoAnotacionHelper.crearClaveHistorico(registro));
                hvo.setTipoMovimiento(ConstantesDatos.HIST_ANOT_ENVIO_CORREO);
                hvo.setDetallesMovimiento(xmlMovimiento);
                
                // Insertamos en BBDD el movimiento
                HistoricoMovimientoManager.getInstance().insertarMovimientoHistorico(hvo, con, usuario.getParamsCon());

                // Envio del correo
                MailHelper mailHelper = new MailHelper();
                mailHelper.sendMailWithAttachments(emailDestinatario, subject, content, null, listaDocumentos, null, null, null);
                m_Log.debug("mail enviado");
                
                SigpGeneralOperations.commit(oad, con);
        } catch (BDException bde) {
            SigpGeneralOperations.rollBack(oad, con);
            Logger.getLogger(AnotacionRegistroDAO.class.getName()).log(Level.SEVERE, null, bde);
            throw new AnotacionRegistroException(m_ConfigError.getString("Error.AnotacionRegistroDAO.enviarCorreoDocumentoCotejo"), bde);
        } catch (Exception e) {
            SigpGeneralOperations.rollBack(oad, con);
            Logger.getLogger(AnotacionRegistroDAO.class.getName()).log(Level.SEVERE, null, e);
            throw new AnotacionRegistroException(m_ConfigError.getString("Error.AnotacionRegistroDAO.enviarCorreoDocumentoCotejo"), e);
        } finally {
            SigpGeneralOperations.devolverConexion(oad, con);
        }
    }
	/**
     * Obtener la descripcion del metadato "Tipo de Firma"
     * de los documentos cotejados
     * 
     * @param id
     * @param params
     * @return
     * @throws SQLException 
     */
    public String obtenerDescripcionTipoFirmaMetadatosCotejoById(Integer id, String[] params) throws SQLException {
        AdaptadorSQLBD adapt = null;
        Connection con = null;
        List<KeyValueObject<Integer, String>> lista = null;
        String descripcion = null;

        try {
            adapt = new AdaptadorSQLBD(params);
            con = adapt.getConnection();

            lista = AnotacionRegistroDAO.getInstance().obtenerTiposMetadatosCotejo(id, TablaMetadatos.TIPO_FIRMA, con);
            
            if (lista != null && !lista.isEmpty()) {
                descripcion = lista.get(0).getValue();
            }
        } catch (BDException e) {
            m_Log.error(this.getClass().getName() + " - ERROR al recuperar una conexión a la BBDD: " + e.getMessage());

        } finally {
            try {
                if (con != null) {
                    con.close();
                }

            } catch (SQLException e) {
                m_Log.error(this.getClass().getName() + " - ERROR al cerrar conexión a la BBDD: " + e.getMessage());
            }
        }
        return descripcion;
    }

    /**
     * Obtiene un listado de los registros contenidos en las tablas de metadatos.
     * El parametro enumTabla se usara para determinar a que tabla se desea acceder.
     * 
     * @param id
     * @param enumTabla
     * @param params 
     * @return
     * @throws SQLException 
     */
    public List<KeyValueObject<Integer, String>> obtenerTiposMetadatosCotejo(Integer id, TablaMetadatos enumTabla, String[] params) throws SQLException {
        AdaptadorSQLBD adapt = null;
        Connection con = null;
        List<KeyValueObject<Integer, String>> lista = null;

        try {
            adapt = new AdaptadorSQLBD(params);
            con = adapt.getConnection();

            lista = AnotacionRegistroDAO.getInstance().obtenerTiposMetadatosCotejo(id, enumTabla, con);

        } catch (BDException e) {
            m_Log.error(this.getClass().getName() + " - ERROR al recuperar una conexión a la BBDD: " + e.getMessage());

        } finally {
            try {
                if (con != null) {
                    con.close();
                }

            } catch (SQLException e) {
                m_Log.error(this.getClass().getName() + " - ERROR al cerrar conexión a la BBDD: " + e.getMessage());
            }
        }
        return lista;
    }
	
    
	/**
     * Rellena los metadatos de un documento cotejado de la HashTable pasada por parametro
     * @param datos
     * @param regDoc 
     */
    private void rellenarMetadatosDocumentoCotejado(Hashtable<String, Object> datos, RegistroValueObject regDoc) {
        // Metadatos de cotejo del documento
        DocumentoMetadatosVO metadatos = regDoc.getMetadatosDoc();
        
        // Como los metadatos de cotejo son obligatorio o existen todos o estan todos a null.
        if (metadatos != null) {
            datos.put("versionNTIMetadatos", metadatos.getVersionNTI());
            
            datos.put("organoMetadatos", metadatos.getOrgano());
            datos.put("fechaCapturaMetadatos", metadatos.getFechaCaptura());
            datos.put("origenMetadatos", metadatos.getOrigen());
            datos.put("estadoElaboracionMetadatos", metadatos.getEstadoElaboracion());
            datos.put("nombreFormatoMetadatos", metadatos.getNombreFormato());
            datos.put("tipoDocumentalMetadatos", metadatos.getTipoDocumental());
            datos.put("tipoFirmaMetadatos", metadatos.getTipoFirma());
            if (metadatos.getIdDocumento() != null) {	
            	datos.put("idDocumentoMetadatos", metadatos.getIdDocumento());	
             }
        }
    }
	
    public boolean generarCSVJustificante(GeneralValueObject params) {
        boolean correcto = false;
        ByteArrayOutputStream outputStream = null;
        ByteArrayInputStream inputStream = null;

        m_Log.debug("generarCSVJustificante");

        try {
            UsuarioValueObject usuario = (UsuarioValueObject) params.getAtributo("usuario");
            String directorio = (String) params.getAtributo("directorio");
            String nombrePdfGenerado = (String) params.getAtributo("nombrePdfGenerado");
            String nombrePdfGeneradoCompleto = (String) params.getAtributo("nombrePdfGeneradoCompleto");
            

            // Leer el fichero generado anteriormente
             String rutaCompletaFichero ="";
            if((nombrePdfGeneradoCompleto!=null)&&(!"".equals(nombrePdfGeneradoCompleto))){
                rutaCompletaFichero=nombrePdfGeneradoCompleto;
            }
            else{
                rutaCompletaFichero = String.format("%s%s%s", directorio, File.separator, nombrePdfGenerado);
            }
            params.setAtributo("rutaCompletaFichero", rutaCompletaFichero);

            if (m_Log.isDebugEnabled()) {
                m_Log.debug(String.format("Ubicacion fichero: %s", rutaCompletaFichero));
            }

            byte[] ficheroDoc = FileUtils.readFileToByteArray(new File(rutaCompletaFichero));
            outputStream = new ByteArrayOutputStream();
            inputStream = new ByteArrayInputStream(ficheroDoc);
            
            
            String codigoCSV = "";
            boolean generarCSV = CodigoSeguroVerificacionHelper.incrustarCSVenJustificante(usuario.getOrgCod(), registroConf);

            if (generarCSV) {
                // Incrustar el CSV en el pdf
                String cabeceraCSV = ""; // TODO implementar cabecera
                codigoCSV = DocumentoManager.getInstance().incrustarCSVenPDF(inputStream, outputStream, cabeceraCSV, usuario.getNombreUsu(), String.valueOf(usuario.getOrgCod()));
            } else {
                IOUtils.copy(inputStream,outputStream);
            }

            // Almacenar el documento
            almacenarJustificanteCSV(params, outputStream, codigoCSV);

            correcto = true;
        } catch (Exception e) {
            m_Log.error("Error al intentar generar el documento con CSV", e);
            correcto = false;
        } finally {
            IOUtils.closeQuietly(inputStream);
            IOUtils.closeQuietly(outputStream);
        }

        return correcto;
    }

    private void almacenarJustificanteCSV(GeneralValueObject parametros,
            ByteArrayOutputStream outputStream, String codigoCSV)
            throws TechnicalException {

        m_Log.debug("almacenarJustificanteCSV");

        try {
            String rutaCompletaFichero = (String) parametros.getAtributo("rutaCompletaFichero");
            byte[] fichero = outputStream.toByteArray();
            Calendar fechaDoc = Calendar.getInstance();
            String tipoMimeCSV = MimeTypes.PDF[0];
            String extensionCSV = MimeTypes.FILEEXTENSION_PDF;
            String entregado = ConstantesDatos.NO;
            
            // Generar el nombre del justificante
            String nombreDocumentoCSV = String.format("%s%s.%s",
                    ConstantesDatos.PREFIJO_FICHERO_JUSTIFICANTE_CSV,
                    DateOperations.toString(fechaDoc, DateOperations.DATE_TIME_FOR_FILE_WITH_MILIS),
                    extensionCSV);
            parametros.setAtributo("nombreDocumentoCSV", nombreDocumentoCSV);
            
            // Metadatos del documento
            MetadatosDocumentoVO metadatosCSV = new MetadatosDocumentoVO();
            metadatosCSV.setCsv(codigoCSV);
            metadatosCSV.setCsvAplicacion(ConstantesDatos.APLICACION_ORIGEN_DOCUMENTO_FLEXIA);
            metadatosCSV.setCsvUri(generarUriCsvDescargaFichero(parametros));

            if (m_Log.isDebugEnabled()) {
                m_Log.debug(String.format("nombreDocumentoCSV: %s", nombreDocumentoCSV));
                m_Log.debug(String.format("tipoMimeCSV: %s", tipoMimeCSV));
                m_Log.debug(String.format("extensionCSV: %s", extensionCSV));
                m_Log.debug(String.format("fechaDoc: %s", fechaDoc));
                m_Log.debug(String.format("entregado: %s", ConstantesDatos.SI));
                m_Log.debug(String.format("metadatosCSV: %s", metadatosCSV));
            }

            parametros.setAtributo("tipoMimeCSV", tipoMimeCSV);
            parametros.setAtributo("extensionCSV", extensionCSV);
            parametros.setAtributo("fechaDoc", fechaDoc);
            parametros.setAtributo("fichero", fichero);
            parametros.setAtributo("entregado", entregado);
            parametros.setAtributo("metadatosCSV", metadatosCSV);
            
            // Grabar el documento en el almacen
            grabarDocumentoCSV(parametros);

            // Sobreescribir el fichero PDF sin CSV
            FileUtils.writeByteArrayToFile(new File(rutaCompletaFichero), fichero);
        } catch (Exception e) {
            throw new TechnicalException("Error al intentar almacenar el fichero", e);
        }
    }

    /**
     * Genera la URL de descarga del fichero a partir del csv
     * @param parametros
     * @return 
     */
    public String generarUriCsvDescargaFichero(GeneralValueObject parametros) {
        DocumentoManager documentoManager = DocumentoManager.getInstance();
        Map<String, Object> paramUrlCsv = new HashMap<String, Object>();

        String ejercicio = (String) parametros.getAtributo("ejercicio");
        String numero = (String) parametros.getAtributo("numero");
        String codTip = (String) parametros.getAtributo("codTip");
        String nombreDocumentoCSV = (String) parametros.getAtributo("nombreDocumentoCSV");
        String codOur = (String) parametros.getAtributo("codOur");
        String codDep = (String) parametros.getAtributo("codDep");
        String tipoMime = (String) parametros.getAtributo("tipoMimeCSV");
        Boolean isExpHistorico = (Boolean) parametros.getAtributo("isExpHistorico");
        Integer idOrganizacion = (Integer) parametros.getAtributo("idOrganizacion");

        //<ejercicio>§¥<numero>§¥<codTip>§¥<nombreDocumentoCSV>§¥<codOur>§¥<codDep>§¥<tipoMime>
        StringBuilder codigo = new StringBuilder();
        codigo.append(ejercicio)
                .append(ConstantesDatos.SEPARADOR)
                .append(numero)
                .append(ConstantesDatos.SEPARADOR)
                .append(codTip)
                .append(ConstantesDatos.SEPARADOR)
                .append(nombreDocumentoCSV)
                .append(ConstantesDatos.SEPARADOR)
                .append(codOur)
                .append(ConstantesDatos.SEPARADOR)
                .append(codDep)
                .append(ConstantesDatos.SEPARADOR)
                .append(tipoMime);

        paramUrlCsv.put("codigo", codigo);
        paramUrlCsv.put("opcion", "8");
        paramUrlCsv.put("expHistorico", isExpHistorico);
        paramUrlCsv.put("organizacion", idOrganizacion);
        

        return documentoManager.crearURLCodigoSeguroVerificacion(paramUrlCsv);
    }

    public void grabarDocumentoCSV(GeneralValueObject parametros) throws TechnicalException {
        m_Log.debug("grabarDocumentoCSV");

        Connection con = null;
        AdaptadorSQLBD oad = null;
        boolean manejarConexionBBDD = true;

        try {
            con = (Connection) parametros.getAtributoONulo("conexionBBDD");
            if (con != null) {
                manejarConexionBBDD = false;
            }
            
            if (m_Log.isDebugEnabled()) {
                m_Log.debug(String.format("manejarConexionBBDD: %b", manejarConexionBBDD));
            }
            
            String[] params = (String[]) parametros.getAtributo("paramsBBDD");
            Integer idOrganizacion = (Integer) parametros.getAtributo("idOrganizacion");
            String ejercicio = (String) parametros.getAtributo("ejercicio");
            String numero = (String) parametros.getAtributo("numero");
            String codTip = (String) parametros.getAtributo("codTip");
            String codOur = (String) parametros.getAtributo("codOur");
            String codDep = (String) parametros.getAtributo("codDep");
            String entregado = (String) parametros.getAtributo("entregado");
            String nombreDocumento = (String) parametros.getAtributo("nombreDocumentoCSV");
            Calendar fechaDoc = (Calendar) parametros.getAtributo("fechaDoc");
            String tipoMime = (String) parametros.getAtributo("tipoMimeCSV");
            String extension = (String) parametros.getAtributo("extensionCSV");
            byte[] fichero = (byte[]) parametros.getAtributo("fichero");
            String rutaCompletaFichero = (String) parametros.getAtributo("rutaCompletaFichero");
            MetadatosDocumentoVO metadatos = (MetadatosDocumentoVO) parametros.getAtributo("metadatosCSV");
            Boolean insertarMetadatoEnBBDD = Boolean.FALSE;

            if (m_Log.isDebugEnabled()) {
                m_Log.debug(String.format("idOrganizacion: %d", idOrganizacion));
                m_Log.debug(String.format("ejercicio: %s", ejercicio));
                m_Log.debug(String.format("numero: %s", numero));
                m_Log.debug(String.format("codTip: %s", codTip));
                m_Log.debug(String.format("codOur: %s", codOur));
                m_Log.debug(String.format("codDep: %s", codDep));
                m_Log.debug(String.format("entregado: %s", entregado));
                m_Log.debug(String.format("nombreDocumento: %s", nombreDocumento));
                m_Log.debug(String.format("fechaDoc: %s", fechaDoc));
                m_Log.debug(String.format("tipoMime: %s", tipoMime));
                m_Log.debug(String.format("extension: %s", extension));
                m_Log.debug(String.format("rutaCompletaFichero: %s", rutaCompletaFichero));
                m_Log.debug(String.format("metadatos: %s", metadatos));
                m_Log.debug(String.format("tamaño fichero: %d", fichero.length));
            }

            // Iniciamos la transaccion a BD si fuese necesario
            if (manejarConexionBBDD) {
                oad = new AdaptadorSQLBD(params);
                con = oad.getConnection();
                oad.inicioTransaccion(con);
            }
            
            //Obtiene la implementacion del plugin correspondiente                                                
            AlmacenDocumento almacen = AlmacenDocumentoTramitacionFactoria.getInstance(String.valueOf(idOrganizacion)).getImplClassRegistro(String.valueOf(idOrganizacion));
            int tipoDocumento = -1;
            if (!almacen.isPluginGestor()) {
                //Plugin BBDDD
                tipoDocumento = DocumentoTramitacionFactoria.TIPO_DOCUMENTO_BBDD;
            } else {
                //Plugin Gestor Alfresco. No se inserta el binario en la BD de Flexia
                tipoDocumento = DocumentoTramitacionFactoria.TIPO_DOCUMENTO_GESTOR;
            }

            Hashtable<String, Object> datos = new Hashtable<String, Object>();
            datos.put("identDepart", NumberUtils.createInteger(codDep));
            datos.put("unidadOrgan", NumberUtils.createInteger(codOur));
            datos.put("anoReg", NumberUtils.createInteger(ejercicio));
            datos.put("numReg", NumberUtils.createLong(numero));
            datos.put("tipoReg", codTip);
            datos.put("nombreDocumento", nombreDocumento);
            datos.put("tipoDoc", tipoMime);
            datos.put("fichero", fichero);
            datos.put("fechaDoc", DateOperations.toString(fechaDoc, DateOperations.LATIN_DATE_FORMAT));
            datos.put("entregado", entregado);
            datos.put("documentoRegistro", Boolean.TRUE);
            datos.put("estadoDocumentoRegistro", ConstantesDatos.ESTADO_DOCUMENTO_NUEVO);
            datos.put("rutaDocumento", rutaCompletaFichero);
            datos.put("params", params);
            datos.put("codMunicipio", Integer.toString(idOrganizacion));
            datos.put("tipoMime", tipoMime);
            datos.put("extension", extension);
            datos.put("longitudDocumento", fichero.length);
            if (metadatos != null) {
                // CSV
                if (StringUtils.isNotEmpty(metadatos.getCsv())) {
                    datos.put("metadatoDocumentoCsv", metadatos.getCsv());
                    datos.put("metadatoDocumentoCsvAplicacion", metadatos.getCsvAplicacion());
                    datos.put("metadatoDocumentoCsvUri", metadatos.getCsvUri());
                    insertarMetadatoEnBBDD = Boolean.TRUE;
                }
            }
            datos.put("insertarMetadatosEnBBDD", insertarMetadatoEnBBDD);
            
            // TODO de momento solo se implementa el soporta para Almacen de tipo BBDD
            // ES NECESARIO REALIZAR PRUEBAS CON EL GESTOR DOCUMENTAL, YA QUE ESTA
            // PARTE ESTA SIN PROBAR
            if (almacen.isPluginGestor()) {
                //  Si se trata de un plugin de un gestor documental, se pasa la información
                // extra necesaria
                String unidOrgUsuarioQRegistra = codDep;
                String descripcionOrganizacion = OrganizacionesDAO.getInstance().getDescripcionOrganizacion(idOrganizacion, con);
                int codUnidadRegistro = Integer.parseInt(unidOrgUsuarioQRegistra);
                String descripcionUnidadRegistro = null;
                UORDTO uorDTO = (UORDTO) CacheDatosFactoria.getImplUnidadesOrganicas().getDatoClaveUnica(params[6], unidOrgUsuarioQRegistra);
                if (uorDTO
                        != null) {
                    descripcionUnidadRegistro = uorDTO.getUor_nom();
                }
                
                ResourceBundle config = ResourceBundle.getBundle("documentos");
                String carpetaRaiz = config.getString(ConstantesDatos.PREFIJO_PROPIEDAD_ALMACENAMIENTO + idOrganizacion + ConstantesDatos.BARRA + almacen.getNombreServicio() + ConstantesDatos.SUFIJO_PLUGIN_GESTOR_CARPETA_RAIZ);

                ArrayList<String> listaCarpetas = new ArrayList<String>();
                listaCarpetas.add(carpetaRaiz);
                listaCarpetas.add(idOrganizacion + ConstantesDatos.GUION + descripcionOrganizacion);
                listaCarpetas.add(codUnidadRegistro + ConstantesDatos.GUION + descripcionUnidadRegistro);
                
                if (codTip.equalsIgnoreCase("E")) {
                    listaCarpetas.add(ConstantesDatos.DESCRIPCION_ENTRADAS_REGISTRO);
                } else if (codTip.equalsIgnoreCase("S")) {
                    listaCarpetas.add(ConstantesDatos.DESCRIPCION_SALIDAS_REGISTRO);
                }

                listaCarpetas.add(ejercicio + ConstantesDatos.GUION + numero);
                datos.put("listaCarpetas", listaCarpetas);
            }
            
            Documento docReg = DocumentoTramitacionFactoria.getInstance().getDocumento(datos, tipoDocumento);

            // Se da de alta el documento
            ArrayList<Documento> docsRegistroNuevos = new ArrayList<Documento>();
            docsRegistroNuevos.add(docReg);
            almacen.setDocumentosRegistro(docsRegistroNuevos, con);
            
            if (manejarConexionBBDD) {
                SigpGeneralOperations.commit(oad, con);
            }
            
            m_Log.debug("Documento con CSV insertado correctamente");
        } catch (AlmacenDocumentoTramitacionException adte) {
            if (manejarConexionBBDD) {
                SigpGeneralOperations.rollBack(oad, con);
            }
            throw new TechnicalException("Error al intentar grabar el documento", adte);
        } catch (BDException bde) {
            if (manejarConexionBBDD) {
                SigpGeneralOperations.rollBack(oad, con);
            }
            throw new TechnicalException("Error al intentar grabar el documento", bde);
        } finally {
            if (manejarConexionBBDD) {
                SigpGeneralOperations.devolverConexion(oad, con);
            }
        }
    }
    
	public HashMap consultaHashEtiquetasValor(GeneralValueObject gVO,String[] params)  throws AnotacionRegistroException {

        //queremos estar informados de cuando este metodo es ejecutado
        m_Log.info("AnotacionRegistroManager.consultaHashEtiquetasValor");

        HashMap mapaEtiquetas;
        try {
            mapaEtiquetas = AnotacionRegistroDAO.getInstance().consultaHashEtiquetasValor(gVO,params);
        } catch (Exception e) {
            m_Log.error("JDBC Technical problem " + e.getMessage());
            throw new AnotacionRegistroException("Problema técnico de JDBC " + e.getMessage());
        }
        return mapaEtiquetas;
    }
	
	public ArrayList getListadoEntradasRechazadas(RegistroValueObject registro, String[] params) throws AnotacionRegistroException{
        m_Log.debug("----> getListadoEntradasRechazadas()");
        ArrayList listadoEntradasRechazadas = new ArrayList();
        try{
            listadoEntradasRechazadas = AnotacionRegistroDAO.getInstance().getListadoEntradasRechazadas(registro, params);
           
        }catch (Exception ce) {
                 m_Log.error("JDBC Technical problem in getListadoEntradasRechazadas" + ce.getMessage());
                ce.printStackTrace();
        } 
        return listadoEntradasRechazadas;
	}
	
	public ArrayList getListadoPendientesFinalizar (RegistroValueObject regVO, String filtro, String[] params) throws AnotacionRegistroException{
        m_Log.debug(" --> getListadoPendientesFinalizaar");
        ArrayList listadoPendientesFinalizar = new ArrayList();
        AdaptadorSQLBD adapt = null;
        Connection con = null;
        
        try{
             adapt = new AdaptadorSQLBD(params);
             con = adapt.getConnection();
             listadoPendientesFinalizar = AnotacionRegistroDAO.getInstance().getListadoPendientesDigitalizar(regVO, filtro, con);
            
        }catch(BDException bde){
            m_Log.error("Error al obtener una conexión a la BBDD");
            throw new AnotacionRegistroException("Error al obtener una conexión a la BBDD " + bde);
        } catch(Exception e){
             m_Log.error("JDBC Technical problem in getListadoPendientesFinalizar" + e.getMessage());
                e.printStackTrace();
        }finally{
            try{
                SigpGeneralOperations.devolverConexion(adapt, con);
            } catch (TechnicalException ex) {
                Logger.getLogger(AnotacionRegistroManager.class.getName()).log(Level.SEVERE, null, ex);
            }
            return listadoPendientesFinalizar;
        }
    } 
		
	private ArrayList getMetadatosDocumentosModificados(Vector documentosActuales, Vector documentosAntiguos, Connection con){
        m_Log.debug("getMetadatosDocumentosModificados");
        ArrayList<DocumentoMetadatosVO> listadoMetadatosDocumento = new ArrayList<DocumentoMetadatosVO>();
        ArrayList metadatosDocumentosModificados = new ArrayList();
        try{
			for(int i=0; i<documentosAntiguos.size() && i<documentosActuales.size(); i++){
				 RegistroValueObject regDoc = (RegistroValueObject) documentosActuales.elementAt(i);
				 RegistroValueObject regDocAntiguo = (RegistroValueObject) documentosAntiguos.elementAt(i);
				 m_Log.debug("El documento actual recuperado es: " + regDoc.getNombreDoc() + " y el documento antiguo recuperado es: " + regDocAntiguo.getNombreDoc());
				 if(regDoc.getEstadoDocumentoRegistro()==ConstantesDatos.ESTADO_DOCUMENTO_NUEVO){
					 listadoMetadatosDocumento=(ArrayList<DocumentoMetadatosVO>) AnotacionRegistroDAO.getInstance().getMetadatosDocumentoCatalogado(regDocAntiguo, con);
					 for(int j=0; j<listadoMetadatosDocumento.size(); j++){
						 listadoMetadatosDocumento.get(j).setNombreDoc(regDoc.getNombreDoc());
					 }
					metadatosDocumentosModificados.add(listadoMetadatosDocumento);
				 }
			}
        }catch(AnotacionRegistroException ex){
            m_Log.debug(ex.getMessage());
        }
        m_Log.debug("getMetadatosDocumentosModificados:FIN");
        return metadatosDocumentosModificados;
        
    }
		
	private void eliminarMetadatosDocumentosCatalogados(ArrayList<Documento> documentos, Connection con) {
         m_Log.debug("eliminarMetadatosDocumentosCatalogados");
         
         DocumentoCatalogacionVO docCatalog = null;
         try{
             for(Documento documento: documentos){
                 // Convertimos el objeto Documento en un objeto DocumentoCatalogacionVO
                 docCatalog = DocumentoCatalogacionConversor.fromInterfaceDocumento(documento);
                 
                 DigitalizacionDocumentosLanbideDAO.getInstance().borrarDocCatalogacion(docCatalog, con);
             }
         }catch(Exception ex){
              m_Log.error("JDBC Technical problem " + ex.getMessage());
         }
	}
	
	private void insertMetadatosDocumentosModificados(ArrayList metadatosDocumentos, Connection con){
        m_Log.debug("insertMetadatosDocumentosModificados");
        try{
            for(int i=0; i<metadatosDocumentos.size(); i++){
                ArrayList<DocumentoMetadatosVO> metadatosDoc= (ArrayList<DocumentoMetadatosVO>) metadatosDocumentos.get(i);
                for(DocumentoMetadatosVO metaDoc : metadatosDoc){
                    AnotacionRegistroDAO.getInstance().insertMetadatosDocumentoCatalogado(metaDoc, con);
                }
            }
        }catch(Exception ex){
             m_Log.error("JDBC Technical problem " + ex.getMessage());
        }
     }
     
     public String getCodProcedimientoRegistro(RegistroValueObject regVO, String params[]){
         m_Log.info("getCodProcedimientoRegistro: INI");
         String codProcedimiento = null;
        AdaptadorSQLBD adapt = null;
        Connection con = null;
        AnotacionRegistroDAO anotacionDAO = AnotacionRegistroDAO.getInstance();
        try{
            adapt = new AdaptadorSQLBD(params);
            con = adapt.getConnection();
            
            codProcedimiento = anotacionDAO.getCodProcedimientoRegistro(regVO, con);
         }catch(BDException bde){
            m_Log.error("Error al obtener una conexión a la BBDD");
            throw new AnotacionRegistroException("Error al obtener una conexión a la BBDD " + bde);    
        }catch(Exception ex){
            m_Log.error("Ha ocurrido un error al recuperar el código de procedimiento "+ex.getMessage());
        }finally{
             try {
                 SigpGeneralOperations.devolverConexion(adapt, con);
             } catch (TechnicalException ex) {
                m_Log.error("JDBC Technical problem " + ex.getMessage());
             }
            return codProcedimiento;
        }
     }
     
     
     public Boolean getFinDigitalizacionAnotacion(RegistroValueObject regVO, String params[]) throws AnotacionRegistroException{
         m_Log.info("getFinDigitalizacionAnotacion: INI");
        Boolean finDigitalizacion = null;
        AdaptadorSQLBD adapt = null;
        Connection con = null;
        AnotacionRegistroDAO anotacionDAO = AnotacionRegistroDAO.getInstance();
        try{
            adapt = new AdaptadorSQLBD(params);
            con = adapt.getConnection();
            
            finDigitalizacion = anotacionDAO.getFinDigitalizacionAnotacion(regVO, con);
         }catch(BDException bde){
            m_Log.error("Error al obtener una conexión a la BBDD");
            throw new AnotacionRegistroException("Error al obtener una conexión a la BBDD " + bde);    
        }catch(Exception ex){
            m_Log.error("Ha ocurrido un error al comprobar si el proceso de digitalización había finalizado "+ex.getMessage());
        }finally{
             try {
                 SigpGeneralOperations.devolverConexion(adapt, con);
             } catch (TechnicalException ex) {
                m_Log.error("JDBC Technical problem " + ex.getMessage());
             }
        }
        return finDigitalizacion;
     }
     
     /**
      * Recupera el valor de un documento si esta o no migrado
      * @param ejercicio
      * @param numeroEntrada
      * @param tituloDocumento
      * @param params
      * @return 1 si el documento es migrado o bien no existe para que no permita borrarlo, 0 en caso contrario
      * @throws AnotacionRegistroException 
      */
     public String getDocumentoMigrado(Integer ejercicio, Integer numeroEntrada, String tituloDocumento, String params[]) throws AnotacionRegistroException{
         m_Log.info("getDocumentoMigrado: INI");
        String finDigitalizacion = null;
        AdaptadorSQLBD adapt = null;
        Connection con = null;
        AnotacionRegistroDAO anotacionDAO = AnotacionRegistroDAO.getInstance();
        try{
            adapt = new AdaptadorSQLBD(params);
            con = adapt.getConnection();
            
            finDigitalizacion = anotacionDAO.getDocumentoMigrado( ejercicio, numeroEntrada, tituloDocumento, con);
         }catch(BDException bde){
            m_Log.error("Error al obtener una conexión a la BBDD");
            throw new AnotacionRegistroException("Error al obtener una conexión a la BBDD " + bde);    
        }catch(Exception ex){
            m_Log.error("Ha ocurrido un error al recuperar si un documento es migrado "+ex.getMessage());
        }finally{
             try {
                 SigpGeneralOperations.devolverConexion(adapt, con);
             } catch (TechnicalException ex) {
                m_Log.error("JDBC Technical problem " + ex.getMessage());
             }
        }
        m_Log.info("getDocumentoMigrado: FIN");
        return finDigitalizacion;
     }
     
     public void cancelarFinDigitalizacionDocumentos(RegistroValueObject regVO, String[] params) throws AnotacionRegistroException{
        m_Log.info("cancelarFinDigitalizacionDocumentos: INI");
       
        AdaptadorSQLBD adapt = null;
        Connection con = null;
        AnotacionRegistroDAO anotacionDAO = AnotacionRegistroDAO.getInstance();
        try{
            adapt = new AdaptadorSQLBD(params);
            con = adapt.getConnection();
            
            anotacionDAO.cancelarFinDigitalizacionDocumentos(regVO, con);
         }catch(BDException bde){
            m_Log.error("Error al obtener una conexión a la BBDD");
            throw new AnotacionRegistroException("Error al obtener una conexión a la BBDD " + bde);    
        }catch(Exception ex){
            m_Log.error("Ha ocurrido un error al cancelar la finalización de digitalización de documentos "+ex.getMessage());
        }finally{
             try {
                 SigpGeneralOperations.devolverConexion(adapt, con);
             } catch (TechnicalException ex) {
                m_Log.error("JDBC Technical problem " + ex.getMessage());
             }
        }
         
     }
     
      public void cancelarCambioProcedimiento(RegistroValueObject regVO,String codProAnterior, String[] params) throws AnotacionRegistroException{
        m_Log.info("cancelarCambioProcedimiento: INI");
       
        AdaptadorSQLBD adapt = null;
        Connection con = null;
        AnotacionRegistroDAO anotacionDAO = AnotacionRegistroDAO.getInstance();
        try{
            adapt = new AdaptadorSQLBD(params);
            con = adapt.getConnection();
            
            anotacionDAO.cancelarCambioProcedimiento(regVO,codProAnterior, con);
         }catch(BDException bde){
            m_Log.error("Error al obtener una conexión a la BBDD");
            throw new AnotacionRegistroException("Error al obtener una conexión a la BBDD " + bde);    
        }catch(Exception ex){
            m_Log.error("Ha ocurrido un error al cancelar el cambio de procedimiento de una anotación "+ex.getMessage());
        }finally{
             try {
                 SigpGeneralOperations.devolverConexion(adapt, con);
             } catch (TechnicalException ex) {
                m_Log.error("JDBC Technical problem " + ex.getMessage());
             }
        }
         
     }
}
