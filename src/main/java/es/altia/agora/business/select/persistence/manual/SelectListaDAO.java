/* Generated by Together */

package es.altia.agora.business.select.persistence.manual;

import es.altia.agora.business.select.SelectJoinValueObject;
import es.altia.agora.business.select.SelectValueObject;
import es.altia.agora.business.select.exception.SelectListaException;
import es.altia.agora.business.util.ElementoListaTablaValueObject;
import es.altia.common.exception.*;
import es.altia.common.service.config.*;
import es.altia.common.service.jdbc.JDBCWrapper;
import es.altia.util.conexion.AdaptadorSQLBD;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.Vector;


public class SelectListaDAO {

    /**
     * Construye un nuevo SelectListaDAO. Es protected, por lo que la unica manera de instanciar esta clase
     * es usando el factory method <code>getInstance</code>
     */
    protected SelectListaDAO() {
        super();
        //Queremos usar el fichero de configuracion techserver
        m_ConfigTechnical = ConfigServiceHelper.getConfig("techserver");
        //Queremos tener acceso a los mensajes de error localizados
        m_ConfigError = ConfigServiceHelper.getConfig("error");

        //sql_cod_centro        = m_ConfigTechnical.getString("SQL.gen_agenda.cod_centro");
        //sql_cod_ubic          = m_ConfigTechnical.getString("SQL.gen_agenda.cod_ubic");
        //sql_desc_centro_ubic  = m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.nom_ubic");
    }


    /**
     * Recuperar los codigos y descripciones de una determinada tabla
     * @param laSelect con los nombres de campos y de la tabla para crear la select
     * @exception SelectListaException si existe algun problema tecnico.
     * @exception TechnicalException si hay algun problema tecnico usando los servicios del framework.
     */
	// Esquema BD: añade parametro "String[] params"

    public Vector load(SelectValueObject laSelect,String[] params) throws SelectListaException, TechnicalException
    {

        ElementoListaTablaValueObject elElemento = null;
        Vector laListaCodigos = null;
        int i = 0;

        //Queremos estar informados de cuando este metod es ejecutado
        m_Log.debug("load");

        if(laListaCodigos == null)
        {
           //Obtiene la sentencia sql a ser ejecutada del fichero de configuracion tecnico.
           String sql = "";
           //String sql = m_ConfigTechnical.getString("SQL.gen_valores_tablas.loadListaCond");
           laListaCodigos = new Vector();
           //Usar el JDBCWrapper es mas sencillo que usar JDBC directamente
           JDBCWrapper sqlExec = new JDBCWrapper();
           // ----> Esquema BD
		   if (params != null) sqlExec.setJndi(params[6]);
		   // ---- fin esquema BD
           try
           {
               String col_cod     = laSelect.getCol_cod();
               String col_desc_c  = laSelect.getCol_desc_c();
               AdaptadorSQLBD oad = new AdaptadorSQLBD(params);
               if( col_desc_c.indexOf(oad.getSymbolConcat()) != -1 )
					col_desc_c = col_desc_c + " AS COLUMNA_CONCAT";

               String col_desc_e  = laSelect.getCol_desc_e();
               String nom_tabla   = laSelect.getNom_tabla();

               // Creamos la select con los parametros adecuados (campos y tablas)
               sql = "SELECT " + col_cod;
               if(!("".equals(col_desc_c)))
                  sql = sql + " , " + col_desc_c;
               if(!("".equals(col_desc_e)))
                  sql = sql + " , " + col_desc_e;
               sql = sql + " FROM " + nom_tabla;


			   String sqlWhere="";

				if (laSelect.getColumn_valor_where() != null)
				{
					Vector c = laSelect.getColumn_valor_where();
					if ( (c.size()>1) ){
						 sqlWhere += " where " + c.elementAt(0) + "='"+c.elementAt(1)+"'";
						for (int j=2; j<c.size(); j+=2)
						{
							sqlWhere += " and " + c.elementAt(j) + "='"+ c.elementAt(j+1)+"'";
						}

					}
				}

				if (laSelect.getParteWhereCompleja() != null)
				{
					if (!"".equals(laSelect.getParteWhereCompleja().trim())) {
						if ("".equals(sqlWhere))
							sqlWhere += " where ";
						else sqlWhere += " and ";
							sqlWhere += laSelect.getParteWhereCompleja();
					}
				}
			   sql += sqlWhere;

               sql = sql + " ORDER BY 2";

               if(m_Log.isDebugEnabled()) m_Log.debug("sentencia despues de:" + sql);

               //Ahora el JDBCWrapper tiene suficiente informacion para construir la sentencia sql.
               //De este modo, la podemos ejecutar.

               sqlExec.execute(sql);

               m_Log.debug("Lista codigos: " + sql);
               if( col_desc_c.indexOf(oad.getSymbolConcat()) != -1 )
               {
	               while( sqlExec.next() )
    	           {
        	          if( "".equals(col_desc_e))
	                     //Solo una descripcion
    	                 elElemento = new ElementoListaTablaValueObject(
                                                 sqlExec.getString(col_cod),
								                 sqlExec.getString("COLUMNA_CONCAT"),
                                                 i);
        	          else
            	        //Dos descripciones
                	     elElemento = new ElementoListaTablaValueObject(
                                                 sqlExec.getString(col_cod),
								                 sqlExec.getString("COLUMNA_CONCAT"),
                                                 sqlExec.getString(col_desc_e),
                                                 i);

	                  laListaCodigos.addElement( elElemento );
    	              i++;
	               }
               }
               else
               {
                  while( sqlExec.next() )
    	           {
        	          //if( "".equals(col_desc_e))
	                     //Solo una descripcion
    	                 elElemento = new ElementoListaTablaValueObject(
                                                 sqlExec.getString(col_cod),
								                 sqlExec.getString(col_desc_c),
                                                 i);
        	          /*else
            	        //Dos descripciones
                	     elElemento = new ElementoListaTablaValueObject(
                                                 sqlExec.getString(col_cod),
								                 sqlExec.getString(col_desc_c),
                                                 sqlExec.getString(col_desc_e),
                                                 i);
*/
	                  laListaCodigos.addElement( elElemento );
    	              i++;
	               }
               }
                m_Log.debug("Cargada la lista de codigos de la tabla.");
            }
            catch (Exception e)
            {
                m_Log.error("EXCEPTION" + e.getMessage());
                //Si la eliminacion va mal tenemos que lanzar y loggear la excepcion
                m_Log.error(e.getMessage());
              throw new SelectListaException(m_ConfigError.getString("Error.ListaSelectCondDAO.load"), e);
            }
            finally {
                if (sqlExec!=null) sqlExec.close();
            }
        }
        //Queremos estar informados de cuando este metodo ha finalizado
        m_Log.debug("load");

        return(laListaCodigos);
    }

    /**
     * Recuperar las columnas de una determinada tabla
     * @param laSelect con los nombres de campos y de la tabla para crear la select
     * @exception SelectListaException si existe algun problema tecnico.
     * @exception TechnicalException si hay algun problema tecnico usando los servicios del framework.
     */
    public Vector loadCampos(SelectValueObject laSelect) throws SelectListaException, TechnicalException
    {

        ElementoListaTablaValueObject elElemento = null;
        Vector laListaCodigos = null;
        int i = 0;

        //Queremos estar informados de cuando este metod es ejecutado
        m_Log.debug("load");

        if(laListaCodigos == null)
        {
           //Obtiene la sentencia sql a ser ejecutada del fichero de configuracion tecnico.
           String sql = "";
           //String sql = m_ConfigTechnical.getString("SQL.gen_valores_tablas.loadListaCond");
           laListaCodigos = new Vector();
           //Usar el JDBCWrapper es mas sencillo que usar JDBC directamente
           JDBCWrapper sqlExec = new JDBCWrapper();
           Vector lasColumnas = new Vector();
           int max=0;
           int j=0;
           try
           {
               String nom_tabla   = laSelect.getNom_tabla();
               String col_where   = laSelect.getCol_where();
               String valor_where = laSelect.getValor_where();
			   lasColumnas=laSelect.getColumnas();
			   max = lasColumnas.size();
               if(max > 0)
               {
                 sql = "SELECT " + lasColumnas.elementAt(j);
                 while(++j < max)
                 {
 			    	sql = sql + " , " + lasColumnas.elementAt(j);
                 }
               }
               // Creamos la select con los parametros adecuados (campos y tablas)
               sql = sql + " FROM " + nom_tabla;

               if(!("".equals(col_where)))
               {
                  sql = sql + " WHERE " + col_where + " = " + valor_where;
               }
               sql = sql + " ORDER BY 2";

               if(m_Log.isDebugEnabled()) m_Log.debug("sentencia despues" + sql);

               //Ahora el JDBCWrapper tiene suficiente informacion para construir la sentencia sql.
               //De este modo, la podemos ejecutar.

               sqlExec.execute(sql);

               if(m_Log.isDebugEnabled()) m_Log.debug("Lista codigos: " + sql);

               i=0;
               while( sqlExec.next() )
               {
                     //Solo una descripcion
                     elElemento = new ElementoListaTablaValueObject(
                        						sqlExec.getString((String)lasColumnas.elementAt(i)),
								                 "",
                                                 i);
                     laListaCodigos.addElement( elElemento );
                     i++;

               }
                m_Log.debug("Cargada la lista de codigos de la tabla.");
            }
            catch (Exception e)
            {
               //Si la eliminacion va mal tenemos que lanzar y loggear la excepcion
               m_Log.error(e.getMessage());
              throw new SelectListaException(m_ConfigError.getString("Error.ListaSelectCondDAO.load"), e);
            }
            finally {
                if (sqlExec!=null) sqlExec.close();
            }
        }
        //Queremos estar informados de cuando este metodo ha finalizado
        m_Log.debug("load");

        return(laListaCodigos);
    }



    /**
     * Recuperar los codigos y descripciones de una determinada tabla,
     * habiendo obtenido antes, los codigos a partir de otra tabla.
     * @param laSelect con los nombres de campos y de la tabla para crear la select
     * @exception SelectListaException si existe algun problema tecnico.
     * @exception TechnicalException si hay algun problema tecnico usando los servicios del framework.
     */
    public Vector loadJoin(SelectJoinValueObject laSelectJoin) throws SelectListaException, TechnicalException
    {

        ElementoListaTablaValueObject elElemento = null;
        Vector laListaCodigos = null;
        int i = 0;

        //Queremos estar informados de cuando este metod es ejecutado
        m_Log.debug("load");

        if(laListaCodigos == null)
        {
           //Obtiene la sentencia sql a ser ejecutada del fichero de configuracion tecnico.
           String sql = "";
           //String sql = m_ConfigTechnical.getString("SQL.gen_valores_tablas.loadListaCond");
           laListaCodigos = new Vector();
           //Usar el JDBCWrapper es mas sencillo que usar JDBC directamente
           JDBCWrapper sqlExec = new JDBCWrapper();

           try
           {
               String col_cod1_tabla1 = laSelectJoin.getCol_cod1_tabla1();
               String col_cod2_tabla1 = laSelectJoin.getCol_cod2_tabla1();
               String nom_tabla1 = laSelectJoin.getNom_tabla1();
               String nom_tabla2 = laSelectJoin.getNom_tabla2();
               String col_cod_tabla2 = laSelectJoin.getCol_cod_tabla2();
               String col_desc_tabla2 = laSelectJoin.getCol_desc_tabla2();
               String valor_where = laSelectJoin.getValor_where();

               // Creamos la select con los parametros adecuados (campos y tablas)
               sql = " SELECT "+nom_tabla2+"."+col_cod_tabla2+", "+nom_tabla2+"."+col_desc_tabla2+
                     " FROM "+nom_tabla1+", "+nom_tabla2+
                     " WHERE "+nom_tabla1+"."+col_cod2_tabla1+"="+nom_tabla2+"."+col_cod_tabla2+
                     " AND "+nom_tabla1+"."+col_cod1_tabla1+"="+valor_where ;
               sql = sql + " ORDER BY 2";

               if(m_Log.isDebugEnabled()) m_Log.debug("sentencia despues" + sql);

               //Ahora el JDBCWrapper tiene suficiente informacion para construir la sentencia sql.
               //De este modo, la podemos ejecutar.

               m_Log.debug("ANTES DE EJECUTAR:");
               sqlExec.execute(sql);

               if(m_Log.isDebugEnabled()) m_Log.debug("Lista codigos: " + sql);
               m_Log.debug("ANTES DE LA SELECT:");
               while( sqlExec.next() )
               {
                  m_Log.debug("EN LA SELECT:");
                  elElemento = new ElementoListaTablaValueObject(
                                                 sqlExec.getString(col_cod_tabla2),
								                 sqlExec.getString(col_desc_tabla2),
                                                 i);

                  laListaCodigos.addElement( elElemento );
                  i++;
                }

                m_Log.debug("Cargada la lista de codigos de la tabla.");
            }
            catch (Exception e)
            {
               m_Log.error("EXCEPTION:"+ e.getMessage());
               //Si la eliminacion va mal tenemos que lanzar y loggear la excepcion
               m_Log.error(e.getMessage());
              throw new SelectListaException(m_ConfigError.getString("Error.ListaSelectCondDAO.load"), e);
            }
            finally {
               if (sqlExec!=null) sqlExec.close();
            }
        }
        //Queremos estar informados de cuando este metodo ha finalizado
        m_Log.debug("load");

        return(laListaCodigos);
    }



     public Vector loadJoin2(SelectJoinValueObject laSelectJoin) throws SelectListaException, TechnicalException
    {

        ElementoListaTablaValueObject elElemento = null;
        Vector laListaCodigos = null;
        int i = 0;

        //Queremos estar informados de cuando este metod es ejecutado
        m_Log.debug("load");

        if(laListaCodigos == null)
        {
           //Obtiene la sentencia sql a ser ejecutada del fichero de configuracion tecnico.
           String sql = "";
           //String sql = m_ConfigTechnical.getString("SQL.gen_valores_tablas.loadListaCond");
           laListaCodigos = new Vector();
           //Usar el JDBCWrapper es mas sencillo que usar JDBC directamente
           JDBCWrapper sqlExec = new JDBCWrapper();

           try
           {
               String col_cod1_tabla1 = laSelectJoin.getCol_cod1_tabla1();
               String col_cod2_tabla1 = laSelectJoin.getCol_cod2_tabla1();
               String col_cod3_tabla1 = laSelectJoin.getCol_cod3_tabla1();
               String nom_tabla1 = laSelectJoin.getNom_tabla1();
               String nom_tabla2 = laSelectJoin.getNom_tabla2();
               String col_cod_tabla2 = laSelectJoin.getCol_cod_tabla2();
               String col_cod2_tabla2 = laSelectJoin.getCol_cod2_tabla2();
               String col_desc_tabla2 = laSelectJoin.getCol_desc_tabla2();
               String valor_where = laSelectJoin.getValor_where();

               // Creamos la select con los parametros adecuados (campos y tablas)
               sql = " SELECT "+nom_tabla2+"."+col_cod_tabla2+", "+nom_tabla2+"."+col_desc_tabla2+
                     " FROM "+nom_tabla1+", "+nom_tabla2+
                     " WHERE "+nom_tabla1+"."+col_cod2_tabla1+"="+nom_tabla2+"."+col_cod_tabla2+
					 " AND "+nom_tabla1+"."+col_cod3_tabla1+"="+nom_tabla2+"."+col_cod2_tabla2+
                     " AND "+nom_tabla1+"."+col_cod1_tabla1+"="+valor_where ;
               sql = sql + " ORDER BY 2";

               if(m_Log.isDebugEnabled()) m_Log.debug("sentencia despues" + sql);

               //Ahora el JDBCWrapper tiene suficiente informacion para construir la sentencia sql.
               //De este modo, la podemos ejecutar.

               sqlExec.execute(sql);

               if(m_Log.isDebugEnabled()) m_Log.debug("Lista codigos: " + sql);
               while( sqlExec.next() )
               {
                  elElemento = new ElementoListaTablaValueObject(
                                                 sqlExec.getString(col_cod_tabla2),
								                 sqlExec.getString(col_desc_tabla2),
                                                 i);

                  laListaCodigos.addElement( elElemento );
                  i++;
                }

                m_Log.debug("Cargada la lista de codigos de la tabla.");
            }
            catch (Exception e)
            {
               //Si la eliminacion va mal tenemos que lanzar y loggear la excepcion
               m_Log.error(e.getMessage());
              throw new SelectListaException(m_ConfigError.getString("Error.ListaSelectCondDAO.load"), e);
            }
            finally {
                if (sqlExec!=null) sqlExec.close();
            }
        }
        //Queremos estar informados de cuando este metodo ha finalizado
        m_Log.debug("load");

        return(laListaCodigos);
    }

    public Vector loadListaCentrosUbic() throws SelectListaException, TechnicalException {

        ElementoListaTablaValueObject elElemento = null;
        Vector laListaCodigos = new Vector();
        int i=0;
        String sql = m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.loadListaCentrosUbic");
        if(m_Log.isDebugEnabled()) m_Log.debug(sql);
        JDBCWrapper sqlExec = new JDBCWrapper();
        try {
            sqlExec.execute(sql);
			while(sqlExec.next()) {
                  String cod_centro = sqlExec.getString(sql_cod_centro) + sqlExec.getString(sql_cod_ubic);
                  if(m_Log.isDebugEnabled()){
                      m_Log.debug("******cod_centro "+cod_centro);
                      m_Log.debug("******desc_centro_ubicc "+sqlExec.getString(sql_desc_centro_ubic));
                  }
                  elElemento = new ElementoListaTablaValueObject(
                                                 cod_centro,
								                 sqlExec.getString(sql_desc_centro_ubic),
                                                 i);
                  laListaCodigos.addElement(elElemento);
                  i++;
                }
        } catch (Exception e) {
            //Si algo va mal en la actualización debemos lanzar y loggear la excepcion
            m_Log.error(e.getMessage());
            throw new SelectListaException(m_ConfigError.getString("Error.ListaSelectCondDAO.loadListaCentrosUbic"), e);
        } finally {
            //Debemos cerrar la conexion de la BD
 			if (sqlExec!=null) sqlExec.close();
        }
        return laListaCodigos;
    }


    /**
     * Factory method para el<code>Singelton</code>.
     * @return La unica instancia de SelectListaDAO.The only CustomerDAO instance.
     */
    public static SelectListaDAO getInstance() {
        //si no hay ninguna instancia de esta clase tenemos que crear una
        if (instance == null) {
            // Necesitamos sincronizacion para serializar (no multithread)
            // Las invocaciones de este metodo
            synchronized(SelectListaDAO.class) {
                if (instance == null) {
                    instance = new SelectListaDAO();
                }
            }
        }
        return instance;
    }

     /*
     * Mi propia instancia. Usada en el metodo getInstance
     */

    private static SelectListaDAO instance = null;

     /*
     * Declaracion de servicios
     */

    protected static Config m_ConfigTechnical; //Para el fichero de configuracion tecnico
    protected static Config m_ConfigError; //Para los mensajes de error localizados
    protected static Log m_Log =
            LogFactory.getLog(SelectListaDAO.class.getName());


    //Nombres campos loadListaCentrosUbic
    protected static String sql_cod_centro;
    protected static String sql_cod_ubic;
    protected static String sql_desc_centro_ubic;

}
