/* Generated by Together */

package es.altia.agora.business.administracion.persistence.manual;

import es.altia.agora.business.administracion.AgendaValueObject;
import es.altia.agora.business.administracion.CitasAgendaValueObject;
import es.altia.agora.business.administracion.GestionValueObject;
import es.altia.agora.business.administracion.exception.GestionException;
import es.altia.agora.technical.Fecha;
import es.altia.common.exception.*;
import es.altia.common.service.config.*;
import es.altia.common.service.jdbc.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.Calendar;
import java.util.Date;
import java.util.Vector;
public class AgendaDAO {

    /**
     * Construerye una nueva AgendaDAO. Es protected, por lo que la unica manera de instanciar esta clase
     * es usando el factory method <code>getInstance</code>
     */
    protected AgendaDAO() {
        super();
        //Queremos usar el fichero de configuracion techserver
        m_ConfigTechnical = ConfigServiceHelper.getConfig("techserver");
        //Queremos tener acceso a los mensajes de error localizados
        m_ConfigError = ConfigServiceHelper.getConfig("error");
        //Queremos usar el fichero de configuracion de langai
        m_ConfigLangai = ConfigServiceHelper.getConfig("langai");

    }

    /**
     * Comprueba si la fecha de hoy es laborable o festivo
     * @param     laGestion GestionValueObject
     * @exception GestionException si existe algun problema tecnico.
     * @exception TechnicalException si hay algun problema tecnico usando los servicios del framework.
     */
    public void comprobarDia(GestionValueObject laGestion) throws GestionException, TechnicalException
    {
        //Queremos estar informados de cuando este metod es ejecutado
        m_Log.debug("comprobar dia");

        //Usar el JDBCWrapper es mas sencillo que usar JDBC directamente
        JDBCWrapper sqlExec = new JDBCWrapper();

        //Vector donde iran almacenados los parametros de la sentencia SQL.
        Vector params = new Vector();

        String laborable = "no";

        try {
           String sql = m_ConfigTechnical.getString("SQL.gen_calendario.comprobarDia");
           sqlExec.execute(sql, laGestion.getFecha());

           if(sqlExec.next())
              laborable = "no";
           else{
              params.addElement(laGestion.getFecha());
              params.addElement(laGestion.getCentro());
              params.addElement(laGestion.getUbicacion());
              sql = m_ConfigTechnical.getString("SQL.gen_calendario_ubicac.comprobarDia");
              sqlExec.execute(sql, params);

              if(sqlExec.next())
                 laborable = "no";
              else
                 laborable = "si";
           }

           laGestion.setLaborable(laborable);

           m_Log.debug("Comprobado si el dia es laborable");

        } catch (Exception e){
             //Si la eliminacion va mal tenemos que lanzar y loggear la excepcion
             m_Log.error(e.getMessage());
             throw new GestionException(m_ConfigError.getString("Error.Agenda.comprobarDia"), e);
          } finally {
             if (sqlExec!=null) sqlExec.close();
            }

        //Queremos estar informados de cuando este metodo ha finalizado
        m_Log.debug("comprobado si el dia es laborable");
    }


    /**
     * Recupera el horario de trabajo de un centro y una ubicacion
     * @param     GestionValueObject
     * @exception GestionException si existe algun problema tecnico.
     * @exception TechnicalException si hay algun problema tecnico usando los servicios del framework.
     */
    public void obtenerHoras(GestionValueObject laGestion) throws GestionException, TechnicalException
    {
        //Queremos estar informados de cuando este metod es ejecutado
        m_Log.debug("obtener horas normales");

        Vector horas_normales = new Vector();
        Vector horas_especiales = new Vector();
        Vector horas_reducidas = new Vector();
        int i=0,j,k;

        try
        {
           horas_normales = obtenerHorasNormales(laGestion);
           horas_especiales = obtenerHorasEspeciales(laGestion, horas_normales);

           if ((horas_normales.size() == 0)&&(horas_especiales.size()== 0))
           {
          Vector listaError =new Vector(1,1);
                listaError.add(m_ConfigError.getString("Error.Agenda.horas"));
                listaError.add(m_ConfigError.getString("Error.Agenda.entidad")+laGestion.getCentro());
                listaError.add(m_ConfigError.getString("Error.Agenda.centro")+laGestion.getUbicacion());
                listaError.add(m_ConfigError.getString("Error.Agenda.dia")+laGestion.getFecha());
                laGestion.setListaMensajesError(listaError);
                laGestion.setError("si");
                if (m_Log.isDebugEnabled()) m_Log.debug("Faltan hay horas laborables para el dia: "+laGestion.getFecha());
           }
           else
           {

              if(! horas_especiales.isEmpty())
              {
                  laGestion.setLista_horas_validas(horas_especiales);

                  for(k=0;i<horas_normales.size();i++)
                  {

                    for(j=0;j<horas_especiales.size();j++)
                    {
                        if(horas_normales.elementAt(i).toString().equals(horas_especiales.elementAt(j).toString()))
                        {
                            k=0; break;
                        }
                        else
                            k=1;
                    }

                    if(k==1)
                        horas_reducidas.addElement(horas_normales.elementAt(i).toString());
                  }
                  laGestion.setLista_horas_reducidas(horas_reducidas);
              }

              else
              {
                  laGestion.setLista_horas_validas(horas_normales);
                  laGestion.setLista_horas_reducidas(new Vector());
              }

              m_Log.debug("Obtenido el horario");
           }
        }
        catch (Exception e)
        {
             //Si la eliminacion va mal tenemos que lanzar y loggear la excepcion
             m_Log.error(e.getMessage());
             throw new GestionException(m_ConfigError.getString("Error.Agenda.obtenerHoras"), e);
        }

        //Queremos estar informados de cuando este metodo ha finalizado
        m_Log.debug("Obtenido el horario ");
    }


    /**
     * Recupera las horas normales de trabajo de un centro y una ubicacion, dependiendo de la fecha
     * @param     GestionValueObject
     * @return    un vector con las horas normales de trabajo correspondientes a un centro y una fecha.
     * @exception GestionException si existe algun problema tecnico.
     * @exception TechnicalException si hay algun problema tecnico usando los servicios del framework.
     */
    public Vector obtenerHorasNormales(GestionValueObject laGestion) throws GestionException, TechnicalException
    {
        //Queremos estar informados de cuando este metod es ejecutado
        m_Log.debug("obtener horas normales");

        //Usar el JDBCWrapper es mas sencillo que usar JDBC directamente
        JDBCWrapper sqlExec = new JDBCWrapper();
        String sql;

        //Vector donde iran almacenados los parametros de la sentencia SQL.
        Vector params = new Vector();

        //Vector donde ira almacenado el horario normal.
        Vector horas_normales = new Vector();

        String horaNorm_ini_m, horaNorm_fin_m, horaNorm_ini_t, horaNorm_fin_t;
        int horaIni, horaFin;

        try {

           //Se añaden al vector los parametros necesarios para llevar a cabo la query.
           params.addElement(laGestion.getCentro());
           params.addElement(laGestion.getUbicacion());

           //Ahora el JDBCWrapper tiene suficiente informacion para construir la sentencia sql.
           //De este modo, la podemos ejecutar.
           if(laGestion.getDia()!=6)
              sql = m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.obtenerHorarioNormal");
           else
              sql = m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.obtenerHorarioNormalSab");

           sqlExec.execute(sql, params);

           if(sqlExec.next()){
               if(laGestion.getDia()!=6){
                  horaNorm_ini_m =  m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.hora_ini_m");
                  horaNorm_fin_m =  m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.hora_fin_m");
                  horaNorm_ini_t =  m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.hora_ini_t");
                  horaNorm_fin_t =  m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.hora_fin_t");
               }
               else{
                  horaNorm_ini_m =  m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.hora_ini_m_sab");
                  horaNorm_fin_m =  m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.hora_fin_m_sab");
                  horaNorm_ini_t =  m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.hora_ini_t_sab");
                  horaNorm_fin_t =  m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.hora_fin_t_sab");
               }

//               horaIni = Integer.parseInt(sqlExec.getString(horaNorm_ini_m).substring(0,2));
//               horaFin = Integer.parseInt(sqlExec.getString(horaNorm_fin_m).substring(0,2));
               horaIni = Integer.parseInt(sqlExec.getString(horaNorm_ini_m) == null ? "0" :sqlExec.getString(horaNorm_ini_m).substring(0,2));
               horaFin = Integer.parseInt(sqlExec.getString(horaNorm_fin_m) == null ? "0" :sqlExec.getString(horaNorm_fin_m).substring(0,2));
               //Inic Raquel
               int minutos = Integer.parseInt(sqlExec.getString(horaNorm_fin_m) == null ? "0" :sqlExec.getString(horaNorm_fin_m).substring(3));
               if (minutos != 0)
          horaFin++;
               //Fin Raquel
               for(;horaIni<horaFin;horaIni++)
                   horas_normales.addElement(String.valueOf(horaIni));

               horaIni = Integer.parseInt(sqlExec.getString(horaNorm_ini_t) == null ? "0" : sqlExec.getString(horaNorm_ini_t).substring(0,2));
               horaFin = Integer.parseInt(sqlExec.getString(horaNorm_fin_t) == null ? "0" : sqlExec.getString(horaNorm_fin_t).substring(0,2));
               //Inic Raquel
               minutos = Integer.parseInt(sqlExec.getString(horaNorm_fin_t) == null ? "0" :sqlExec.getString(horaNorm_fin_t).substring(3));
               if (minutos != 0)
          horaFin++;
               //Fin Raquel
               for(;horaIni<horaFin;horaIni++)
                   horas_normales.addElement(String.valueOf(horaIni));

           }
           m_Log.debug("Obtenido el horario normal");

        } catch (Exception e){
             //Si la eliminacion va mal tenemos que lanzar y loggear la excepcion
             m_Log.error(e.getMessage());
             throw new GestionException(m_ConfigError.getString("Error.Agenda.obtenerHorarioNormal"), e);
          } finally {
              if (sqlExec!=null) sqlExec.close();
            }

        //Queremos estar informados de cuando este metodo ha finalizado
        m_Log.debug("Obtenido el horario normal");

        return horas_normales;
    }


    /**
     * Recupera las horas especiales de trabajo de un centro y una ubicacion, dependiendo de la fecha
     * @param     GestionValueObject
     * @return    un vector con las horas especiales de trabajo correspondientes a un centro y una fecha.
     * @exception GestionException si existe algun problema tecnico.
     * @exception TechnicalException si hay algun problema tecnico usando los servicios del framework.
     */
     public Vector obtenerHorasEspeciales(GestionValueObject laGestion, Vector horas_normales) throws GestionException, TechnicalException
     {
        //Queremos estar informados de cuando este metod es ejecutado
        m_Log.debug("obtener horas especiales");

        //Usar el JDBCWrapper es mas sencillo que usar JDBC directamente
        JDBCWrapper sqlExec = new JDBCWrapper();

        //Vector donde iran almacenados los parametros de la sentencia SQL.
        Vector params = new Vector();

        //Vector donde ira almacenado el horario normal.
        Vector horas_especiales = new Vector();

        String horaEspec_ini_m, horaEspec_fin_m, horaEspec_ini_t, horaEspec_fin_t;
        int horaIni, horaFin, i, j;
        Vector aux = new Vector();

        try {

           //Se añaden al vector los parametros necesarios para llevar a cabo la query.
           params.addElement(laGestion.getFecha());
           params.addElement(laGestion.getCentro());
           params.addElement(laGestion.getUbicacion());

           //Ahora el JDBCWrapper tiene suficiente informacion para construir la sentencia sql.
           //De este modo, la podemos ejecutar.
           String sql = m_ConfigTechnical.getString("SQL.gen_horario_ubicac.obtenerHorarioEspecial");

           sqlExec.execute(sql, params);

           if(sqlExec.next()){

              horaEspec_ini_m =  m_ConfigTechnical.getString("SQL.gen_horario_ubicac.hora_ini_m");
              horaEspec_fin_m =  m_ConfigTechnical.getString("SQL.gen_horario_ubicac.hora_fin_m");
              horaEspec_ini_t =  m_ConfigTechnical.getString("SQL.gen_horario_ubicac.hora_ini_t");
              horaEspec_fin_t =  m_ConfigTechnical.getString("SQL.gen_horario_ubicac.hora_fin_t");

//              horaIni = Integer.parseInt(sqlExec.getString(horaEspec_ini_m).substring(0,2));
//              horaFin = Integer.parseInt(sqlExec.getString(horaEspec_fin_m).substring(0,2));

              horaIni = Integer.parseInt(sqlExec.getString(horaEspec_ini_m) == null ? "0" :sqlExec.getString(horaEspec_ini_m).substring(0,2));
              horaFin = Integer.parseInt(sqlExec.getString(horaEspec_fin_m) == null ? "0" :sqlExec.getString(horaEspec_fin_m).substring(0,2));

               //Inic Raquel
               int minutos = Integer.parseInt(sqlExec.getString(horaEspec_fin_m) == null ? "0" :sqlExec.getString(horaEspec_fin_m).substring(3));
               if (minutos != 0)
          horaFin++;
               //Fin Raquel

              for(;horaIni<horaFin;horaIni++)
                 horas_especiales.addElement(String.valueOf(horaIni));

              horaIni = Integer.parseInt(sqlExec.getString(horaEspec_ini_t) == null ? "0" : sqlExec.getString(horaEspec_ini_t).substring(0,2));
              horaFin = Integer.parseInt(sqlExec.getString(horaEspec_fin_t) == null ? "0" : sqlExec.getString(horaEspec_fin_t).substring(0,2));

               //Inic Raquel
               minutos = Integer.parseInt(sqlExec.getString(horaEspec_fin_t) == null ? "0" :sqlExec.getString(horaEspec_fin_t).substring(3));
               if (minutos != 0)
          horaFin++;
              //Fin Raquel

              for(;horaIni<horaFin;horaIni++)
                 horas_especiales.addElement(String.valueOf(horaIni));

           }

           m_Log.debug("Obtenido el horario especial");

        } catch (Exception e){
             //Si la eliminacion va mal tenemos que lanzar y loggear la excepcion
             m_Log.error(e.getMessage());
             throw new GestionException(m_ConfigError.getString("Error.Agenda.obtenerHorarioEspecial"), e);
          } finally {
             if (sqlExec!=null) sqlExec.close();
            }

        //Queremos estar informados de cuando este metodo ha finalizado
        m_Log.debug("Obtenido el horario especial");

        return horas_especiales;
    }


    /**
     * Recupera la agenda de trabajo de un centro y una ubicacion, dependiendo de la fecha
     * @param     GestionValueObject
     * @exception GestionException si existe algun problema tecnico.
     * @exception TechnicalException si hay algun problema tecnico usando los servicios del framework.
     */
    public void getAgenda(GestionValueObject laGestion) throws GestionException, TechnicalException
    {
        //Queremos estar informados de cuando este metod es ejecutado
        m_Log.debug("obtener la agenda");

        //Usar el JDBCWrapper es mas sencillo que usar JDBC directamente
        JDBCWrapper sqlExec = new JDBCWrapper();

        //Vector donde iran almacenados los parametros de la sentencia SQL.
        Vector params = new Vector();

        //Vector donde ira almacenada toda la informacion acerca de la agenda
        Vector lasCitas =new Vector();

        String sql_hora =  m_ConfigTechnical.getString("SQL.gen_agenda_detalle.hora");
        String sql_personas_ir =  m_ConfigTechnical.getString("SQL.gen_agenda_detalle.personas_ir");
        String sql_citas_ir =  m_ConfigTechnical.getString("SQL.gen_agenda_detalle.citas_ir");
        String sql_personas_mmr =  m_ConfigTechnical.getString("SQL.gen_agenda_detalle.personas_mmr");
        String sql_citas_mmr =  m_ConfigTechnical.getString("SQL.gen_agenda_detalle.citas_mmr");
        String sql_valido =  m_ConfigTechnical.getString("SQL.gen_agenda_detalle.valido");

        try {

           //Se añaden al vector los parametros necesarios para llevar a cabo la query.
           params.addElement(laGestion.getFecha());
           params.addElement(laGestion.getCentro());
           params.addElement(laGestion.getUbicacion());

           //Ahora el JDBCWrapper tiene suficiente informacion para construir la sentencia sql.
           //De este modo, la podemos ejecutar.

// VOY AQUI//////////////////////////////////////////////////////////////////////////////////////////
           ///////////////////////////////////////////////////////////////////////////////////////
           //////////////////////////////////////////////////////////////////////////////////////////
           //////////////////////////////////////////////////////////////////////////////////////////
           ////////////////////////////////////////////////////////////////////////////////////////////
           /////////////////////////////////////////////////////////////////////////////////////////////
           ///////////////////////////////////////////////////////////////////////////////////////
           ///////////////////////////////////////////////////////////////////////////////////
           ///////////////////////////////////////////////////////////////////////////
           /////////////////////////////////////////////////////////////////////////////////////////

           String sql = m_ConfigTechnical.getString("SQL.gen_agenda_detalle.obtenerAgenda");

           sqlExec.execute(sql, params);

           while(sqlExec.next()){
              AgendaValueObject laAgenda = new AgendaValueObject();

              laAgenda.setHora(sqlExec.getString(sql_hora));
              laAgenda.setPersonas_ir(sqlExec.getString(sql_personas_ir));
              laAgenda.setCitas_ir(sqlExec.getString(sql_citas_ir));
              laAgenda.setPersonas_mmr(sqlExec.getString(sql_personas_mmr));
              laAgenda.setCitas_mmr(sqlExec.getString(sql_citas_mmr));
              laAgenda.setValido(sqlExec.getString(sql_valido));

              lasCitas.addElement(laAgenda);
           }

           boolean correcto = false;
           int i=0,j=0,k;
           Vector lista_horas_validas = laGestion.getLista_horas_validas();

           //Comprueba si a todas las horas-validas hay citas
           for (i=0;i<lista_horas_validas.size();i++){
               for(j=0;j<lasCitas.size();j++){
                    if( lista_horas_validas.elementAt(i).toString().equals( ((AgendaValueObject)lasCitas.elementAt(j)).getHora().substring(0,1).equals("0") ?  ((AgendaValueObject)lasCitas.elementAt(j)).getHora().substring(1,2) :  ((AgendaValueObject)lasCitas.elementAt(j)).getHora().substring(0,2))){
                          correcto= true;
                          break;
                    }
                    else correcto=false;
               }

               if(! correcto){
                   break;
               }
           }

           //Si hemos obtenido toda la informacion correspondiente al centro y a la fecha......
           if(correcto){
              m_Log.debug("cargando las ciitas..........");
              laGestion.setLista_citas(lasCitas);
              m_Log.debug("Obtenidas las citas");
           }


           //Si falta informacion en la base de datos......
           else{
              Vector faltanHoras=  new Vector();
              String listaFaltanHoras ="";

              for(i=0;i<lista_horas_validas.size();i++){
                 for(j=0,k=0;j<lasCitas.size();j++){
                    if( lista_horas_validas.elementAt(i).toString().equals( ((AgendaValueObject)lasCitas.elementAt(j)).getHora().substring(0,2) ) ){
                       k++;  break;
                    }
                 }
                 if(k==0)
                    faltanHoras.addElement( lista_horas_validas.elementAt(i).toString()+":00  ");
              }

              for(i=0;i<faltanHoras.size();i++)
                listaFaltanHoras = listaFaltanHoras + faltanHoras.elementAt(i).toString();

              Vector listaError =new Vector(1,1);
              listaError.add(m_ConfigError.getString("Error.Agenda.faltaInfo"));
              listaError.add(m_ConfigError.getString("Error.Agenda.entidad")+laGestion.getCentro());
              listaError.add(m_ConfigError.getString("Error.Agenda.centro")+laGestion.getUbicacion());
              listaError.add(m_ConfigError.getString("Error.Agenda.dia")+laGestion.getFecha());
              listaError.add(m_ConfigError.getString("Error.Agenda.horas")+listaFaltanHoras);
              laGestion.setListaMensajesError(listaError);
              laGestion.setError("si");
              if (m_Log.isDebugEnabled()) m_Log.debug("Falta informacion en la agenda sobre alguna de las horas validas del dia: "+laGestion.getFecha());
           }

        } catch (Exception e){
             //Si la eliminacion va mal tenemos que lanzar y loggear la excepcion
             m_Log.error(e.getMessage());
             throw new GestionException(m_ConfigError.getString("Error.Agenda.obtenerAgenda"), e);
          } finally {
              if (sqlExec!=null) sqlExec.close();
            }

        //Queremos estar informados de cuando este metodo ha finalizado
        m_Log.debug("Obtenida la agenda");
    }


     /**
     * Recupera la agenda de trabajo de un centro y una ubicacion, dependiendo de la fecha
     * @param     GestionValueObject
     * @exception GestionException si existe algun problema tecnico.
     * @exception TechnicalException si hay algun problema tecnico usando los servicios del framework.
     */
    public void grabarAgenda(Vector lasAgendas, GestionValueObject laGestion) throws GestionException, TechnicalException
    {
        //Queremos estar informados de cuando este metodo es ejecutado
        m_Log.debug("grabar la agenda");

        //Usar el XAJDBCWrapper es mas sencillo que usar JDBC directamente
        XAJDBCWrapper sqlExec = new XAJDBCWrapper();

        //Obtiene la sentencia sql a ser ejecutada del fichero de configuracion tecnico.
        String sql = m_ConfigTechnical.getString("SQL.gen_agenda_detalle.grabarAgenda");

        String centro = laGestion.getCentro();
        String ubicacion = laGestion.getUbicacion();
        String fecha = laGestion.getFecha();
        //m_Log.debug("Las fecha es: " + fecha);

        int i;

        try{
            for(i=0;i<lasAgendas.size();i++){
                //Vector donde ira almacenada la informacion correspondiente a cada hora
                Vector params = new Vector();

                params.addElement(((AgendaValueObject)lasAgendas.elementAt(i)).getPersonas_ir());
                params.addElement(((AgendaValueObject)lasAgendas.elementAt(i)).getCitas_ir());
                params.addElement(((AgendaValueObject)lasAgendas.elementAt(i)).getPersonas_mmr());
                params.addElement(((AgendaValueObject)lasAgendas.elementAt(i)).getCitas_mmr());
                params.addElement(((AgendaValueObject)lasAgendas.elementAt(i)).getValido());
                params.addElement(centro);
                params.addElement(ubicacion);
                params.addElement(Fecha.obtenerDate(fecha)); //m_Log.debug("feeeeeeeeeeeeeeeeecha" + fecha);
                params.addElement(((AgendaValueObject)lasAgendas.elementAt(i)).getHora());

                sqlExec.execute(sql, params);
            }

            m_Log.debug("Grabada la agenda");

        } catch (Exception e){
             //Si la eliminacion va mal tenemos que lanzar y loggear la excepcion
             m_Log.error(e.getMessage());
             throw new GestionException(m_ConfigError.getString("Error.Agenda.grabarAgenda"), e);
          } finally {
              if (sqlExec!=null) sqlExec.close();
            }

        //Queremos estar informados de cuando este metodo ha finalizado
        m_Log.debug("Grabada la agenda");
    }


    /**
     * Obtiene las citas de la agenda correspondientes a un centro, una fecha y una hora.
     * @param     GestionValueObject
     * @exception GestionException si existe algun problema tecnico.
     * @exception TechnicalException si hay algun problema tecnico usando los servicios del framework.
     */
    public void obtenerCitas(GestionValueObject laGestion) throws GestionException, TechnicalException
    {
        //Queremos estar informados de cuando este metod es ejecutado
        m_Log.debug("obtener citas");

        //Usar el JDBCWrapper es mas sencillo que usar JDBC directamente
        JDBCWrapper sqlExec1 = new JDBCWrapper();
        JDBCWrapper sqlExec2 = new JDBCWrapper();
        String sql1,sql2;

        //Vectores donde iran almacenados los parametros de las sentencias SQL.
        Vector params1 = new Vector();
        Vector params2;

        //Vector donde iran almacenadas todas las citas.
        Vector citas = new Vector();

        //ValueObject donde ira almacenada la informcion de cada cita.
        CitasAgendaValueObject laCita;

        //Parametros de la cita.
        String tipo_doc="",nif="",nombre="",apellido1="",apellido2="",hora="",tipo="",estado="",tfno1="",tfno2="",tfno="";

        try {

           //Se añaden al vector los parametros necesarios para llevar a cabo la query.
           params1.addElement(laGestion.getCentro());
           params1.addElement(laGestion.getUbicacion());
           params1.addElement(laGestion.getFecha());

           //Obtienen las sentencias sql a ser ejecutadas del fichero de configuracion tecnico.
           sql1 = m_ConfigTechnical.getString("SQL.gen_agenda_detalle.obtenerCitas");

           sql2 = m_ConfigTechnical.getString("SQL.gen_agenda_detalle.obtenerIdentificacionCitas");

           sqlExec1.execute(sql1, params1);

           while(sqlExec1.next()){
              //Primero obtenemos el correlativo.
              params2 = new Vector();
              params2.addElement(new Integer(sqlExec1.getInt(m_ConfigTechnical.getString("SQL.dem_cita_previa.dem_cit_corr"))));
              sqlExec2.execute(sql2, params2);

              //Ahora, una vez obtenido el correlativo buscamos el nif y  el nombre de la persona.
              if(sqlExec2.next())
              {
                 tipo_doc  = sqlExec2.getString(m_ConfigTechnical.getString("SQL.gen_persona_fisica.tipo_doc"));
                 nif       = sqlExec2.getString(m_ConfigTechnical.getString("SQL.gen_persona_fisica.num_doc"));
                 nombre    = sqlExec2.getString(m_ConfigTechnical.getString("SQL.gen_persona_fisica.nombre"));
                 apellido1 = sqlExec2.getString(m_ConfigTechnical.getString("SQL.gen_persona_fisica.apellido1"));
                 apellido2 = sqlExec2.getString(m_ConfigTechnical.getString("SQL.gen_persona_fisica.apellido2")) == null ?  " " : sqlExec2.getString(m_ConfigTechnical.getString("SQL.gen_persona_fisica.apellido2"));
                 //Inic Raquel
                 tfno1 	   = sqlExec2.getString(m_ConfigTechnical.getString("SQL.gen_persona_fisica.tlfno1")) == null ?  " " : sqlExec2.getString(m_ConfigTechnical.getString("SQL.gen_persona_fisica.tlfno1"));
                 tfno2 	   = sqlExec2.getString(m_ConfigTechnical.getString("SQL.gen_persona_fisica.tlfno2")) == null ?  " " : sqlExec2.getString(m_ConfigTechnical.getString("SQL.gen_persona_fisica.tlfno2"));
                 if (" ".equals(tfno1))
                  tfno = tfno2;
                 else
                  tfno = tfno1;
                 //Fin Raquel
                 nombre = nombre + " " + apellido1 + " " + apellido2;
              }

              hora = sqlExec1.getString(m_ConfigTechnical.getString("SQL.dem_cita_previa.dem_cit_fecha_alias"));
              tipo = sqlExec1.getString(m_ConfigTechnical.getString("SQL.dem_cita_previa.dem_cit_tipo"));
              estado = sqlExec1.getString(m_ConfigTechnical.getString("SQL.dem_cita_previa.dem_cit_estado"));

              laCita = new CitasAgendaValueObject(tipo_doc, nif, nombre, hora, tipo, estado, tfno);
              citas.addElement(laCita);
           }

           laGestion.setLista_personas_citadas(citas);

           m_Log.debug("Obtenidas las citas");

        } catch (Exception e){
             //Si la eliminacion va mal tenemos que lanzar y loggear la excepcion
             m_Log.error(e.getMessage());
             throw new GestionException(m_ConfigError.getString("Error.Agenda.obtenerCitas"), e);
          } finally {
              if (sqlExec1!=null) sqlExec1.close();
              if (sqlExec2!=null) sqlExec2.close();
            }

        //Queremos estar informados de cuando este metodo ha finalizado
        m_Log.debug("Obtenidas las citas");
    }


/**
     * Obtiene el num max de personas que puede haber en un centro-ubicacion (en I/R y E/T)
     * @param     GestionValueObject
     * @exception GestionException si existe algun problema tecnico.
     * @exception TechnicalException si hay algun problema tecnico usando los servicios del framework.
     */
    public void obtenerNumMaxPersonas(GestionValueObject laGestion) throws GestionException, TechnicalException
    {
        //Queremos estar informados de cuando este metod es ejecutado
        m_Log.debug("obtener num max personas en un centro-ubicacion");

        //Usar el JDBCWrapper es mas sencillo que usar JDBC directamente
        JDBCWrapper sqlExec = new JDBCWrapper();

        Vector params = new Vector();
        Vector num_max_per = new Vector();

        //HorarioCentroValueObject elHorarioCentro;

        try {

           String sql = m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.obtenerNumMaxEntrev");

           params.addElement(laGestion.getCentro());
           params.addElement(laGestion.getUbicacion());

           sqlExec.execute(sql, params);

           String numMaxIR = "";
           String numMaxET = "";
           int aux;

            while(sqlExec.next()){
              numMaxIR = String.valueOf(sqlExec.getInt(m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.num_entrev_ir")));
              numMaxET = String.valueOf(sqlExec.getInt(m_ConfigTechnical.getString("SQL.gen_centros_ubicaciones.num_entrev_eer")));

              num_max_per.addElement(numMaxIR);
              num_max_per.addElement(numMaxET);
           }

          for (int i=0; i<num_max_per.size(); i++) {
            if (m_Log.isDebugEnabled()) m_Log.debug("***"+(String)num_max_per.elementAt(i));
          }

           laGestion.setNum_max_personas(num_max_per);

           m_Log.debug("Obtenido el num max de personas en un centro-ubicacion");

        } catch (Exception e){
             //Si la eliminacion va mal tenemos que lanzar y loggear la excepcion
             m_Log.error(e.getMessage());
             throw new GestionException(m_ConfigError.getString("Error.HorarioCentro.ObtenerNumMaxPersonas"), e);
          } finally {
                if (sqlExec!=null) sqlExec.close();
            }

        //Queremos estar informados de cuando este metodo ha finalizado
        m_Log.debug("Obtenido el num max de personas en un centro-ubicacion");
    }

  //Inic Raquel
    public void generarAgendaCentro (String fec_i, String fec_f, String centro, String ubic) throws TechnicalException, GestionException
    {
  //Obtiene los datos de gen_agenda de los que antes había entrevista
        Vector entrevistas = obtenerDatosEntrevistas(fec_i, fec_f, centro, ubic);

        m_Log.debug("generarAgendaCentro");
  Fecha f = new Fecha();
        Date fecha_i = new Date();
        Date fecha_f = new Date();

    m_Log.debug("");
    if (m_Log.isDebugEnabled()) m_Log.debug("Generando la agenda desde el día " + fec_i + " hasta el día " + fec_f + " para el centro " + centro + " y la ubicacion " + ubic);
    m_Log.debug("");
        //Comprobamos si se pretende buscar por un intervalo de fechas
        //o por una fecha solo
        //Si la fecha de fin es nula, es porq se quiere buscar sólo
        //por la fecha de inicio. Hacemos que la fecha de fin sea
        //igual a la de inicio y así realiza el mismo tratamiento
        //para una fecha sola que para un intervalo.


    //Si la fecha de inicio no es nula, lo transformamos a objeto de tipo date
        if ((fec_i != null)&&(!"".equals(fec_i)))
        {
          fecha_i = f.obtenerDate(fec_i);
      //Si es nula es porq no se busca un intervalo sino un dia,
            //la igualamos a la de inicio
            if ((fec_f == null)||("".equals(fec_f)))
            fecha_f = fecha_i;
            //Si la fecha de fin no es nula, lo transformamos a objetos de tipo date
      else
                fecha_f = f.obtenerDate(fec_f);
        }
        else
        {
            //Si la fecha de inicio es nula, no se ha elegido dia, se lanza una excepcion
      String mens = m_ConfigError.getString("Error.GenerarAgenda.ErrorNoSeleccion");
      m_Log.error(mens);
      throw new GestionException(mens);
        }

        if ((fecha_i == null) || (fecha_f == null))
        {
      String mens = m_ConfigError.getString("Error.GenerarAgenda.ErrorFormatoFecha");
            m_Log.error(mens);
      throw new GestionException(mens);
        }

    //Por si se han especificado mal las fechas y la de fin
        //es previa a la de inicio
        if (fecha_f.before(fecha_i))
        {
            Date f_aux = new Date();
            f_aux = fecha_i;
            fecha_i = fecha_f;
            fecha_f = f_aux;
        }

    //Se borran los datos que existian en la BD previamente para ese
        //intervalo de tiempo
    boolean borrado = borrarAgenda(fecha_i, fecha_f, centro, ubic);
    if (borrado)
      {
      //Obtenemos un vector con los dias comprendidos en el intervalo
            //En el vector los dias se insertan en formato String
          Vector dias = obtenerVectorDias(fecha_i, fecha_f);
      //Eliminamos del vector los dias que no son laborables
      dias = obtenerDiasLaborables(dias, centro, ubic);
      //Si el vector es nulo es porq se ha dado algun error
            if (dias != null)
            {
        //Si el vector tiene tamaño 0 es porque en ese intervalo no hay dias laborales
        if (dias.size() != 0)
                {
              String dia = new String();
          Vector horario = new Vector();
          for (int i = 0; i<dias.size(); i++)
              {
                dia = (String)dias.elementAt(i);
            //Obtenemos el horario de cada uno de los dias del intervalo
                  horario = obtenerHorario(dia, centro, ubic);
                  if  ((horario == null)||(horario.size() == 0))
                  {
                        m_Log.error("ERROR: No existe horario para el día: " + dia);
                  }
                  else
                  {
              //Generamos la agenda para el intervalo de días seleccionado
                    boolean rdo = insertarAgenda(dia, horario, centro, ubic);
                        if (rdo == true)
                        {
                            //m_Log.info("OK");
                        }
                        else
                        {
                String mens = m_ConfigError.getString("Error.GenerarAgenda.InsertarDatos");
                m_Log.error(mens);
                throw new GestionException(mens);
                        }
                  }
              }
            }
                else
                {
                    m_Log.error("No hay dias laborales en el intervalo seleccionado");
                }
      }
            else
            {
                m_Log.error("Error extrayendo dias festivos");
            }
        }
        else
        {
      String mens = m_ConfigError.getString("Error.GenerarAgenda.ErrorBorrandoAgenda");
      m_Log.error(mens);
      throw new GestionException(mens);
        }
        modificarAgendaEntrevistas(entrevistas);
        m_Log.debug("Agenda generada");
    }

  public Vector obtenerVectorDias(Date f_i, Date f_f)
    {
          //Crea un vector con los dias comprendidos en el intervalo seleccionado
            //El vector es un vector de strings
            m_Log.debug("obtenerVectorDias");
      Vector v = new Vector();
            Fecha f = new Fecha();
            Date d = new Date();
            String fecha_texto =  f.obtenerString(f_i);
      //Añade al vector el dia de comienzo del intervalo
      v.addElement(fecha_texto);
      //Se crea un objeto de tipo Calendar para ir aumentando la fecha
            Calendar cal = Calendar.getInstance();
            cal.setTime(f_i);
      while(cal.getTime().before(f_f))
      {
        //Añade un dia hasta llegar al ultimo dia del intervalo
        cal.add(cal.DATE, 1);
                d = cal.getTime();
                fecha_texto = f.obtenerString(d);
              v.addElement(fecha_texto);
            }
            //retorna el vector
            m_Log.debug("obtenido vector dias");
            return v;
    }


    public boolean borrarAgenda (Date f_i, Date f_f, String centro, String ubic) throws GestionException, TechnicalException
    {

    //Borra los datos que han sido previamente insertados en la agenda
        //para ese intervalo de fechas y para ese centro
    m_Log.debug("borrarAgenda");
        //Usar el JDBCWrapper es mas sencillo que usar JDBC directamente
        XAJDBCWrapper sqlExec = new XAJDBCWrapper();

        Vector params = new Vector();
        boolean rdo = true;
    Fecha f = new Fecha();
    //Obtiene la fecha de inicio y de fin del intervalo del vector
        String fecha_i = f.obtenerString(f_i);
        String fecha_f = f.obtenerString(f_f);
        try
        {
          String sql = m_ConfigTechnical.getString("SQL.gen_agenda.borrarAgenda");
      params.addElement(fecha_i);
      params.addElement(fecha_f);
      params.addElement(centro);
      params.addElement(ubic);
      sqlExec.execute(sql, params);
    }
        catch (Exception e)
        {
            rdo = false;
            m_Log.error("Error borrando la agenda");
        }
        finally
        {
                if (sqlExec!=null) sqlExec.close();
        }
        m_Log.debug("Agenda borrada");
        return rdo;
    }


  public Vector obtenerDiasLaborables(Vector v, String centro, String ubic) throws TechnicalException, GestionException
    {
    //Recibe el vector del intervalo de fechas y extrae de él los dias que no son laborales

        m_Log.debug("obtenerDiasLaborables");
    //Extrae del vector los dias festivos de calendario
        v = extraerDiasFestivos(v);
        if (( v != null) && (v.size() != 0))
        {
          //Extrae del vector los dias festivos especificos para ese centro
      v = extraerDiasFestivosCentro(v, centro, ubic);
      if ((v != null)&&(v.size() != 0))
            {
            //Extrae del vector los domingos
        v = extraerDomingos(v);
            }
    }
        m_Log.debug("Dias laborales obtenidos");
        return v;
    }


  public Vector extraerDiasFestivos(Vector v) throws TechnicalException, GestionException
    {
        m_Log.debug("extraerDiasFestivos");
    //Extrae del vector de dias laborales los dias festivos de calendario
        JDBCWrapper sqlExec = new JDBCWrapper();
        Vector params = new Vector();
        Fecha f = new Fecha();
    Date day = new Date();
        String dia = new String();
    //Extrae la fecha de inicio y de fin del intervalo del vector
        String fec_i = (String)v.firstElement();
        String fec_f = (String)v.lastElement();
        String sql = new String();
    String campo = new String();
        String valor = new String();
    int indice = -1;
        try
        {
          sql = m_ConfigTechnical.getString("SQL.gen_agenda.selectIntervaloFestivos");
          params.addElement(fec_i);
          params.addElement(fec_f);
      //Obtiene los dias que aparecen como festivos en la tabla del calendario
            //para el intervalo de fechas seleccionado
      sqlExec.execute(sql, params);
      while (sqlExec.next())
          {
        campo = m_ConfigTechnical.getString("SQL.gen_agenda.diaFestivo");
                day = sqlExec.getDate(campo);
                dia = f.obtenerString(day);
        //Busca ese dia festivo en el vector de fechas
        indice = v.indexOf(dia);
        if (indice == -1)
          v = null;
                else
                  v.remove(indice);
      }
        }
        catch (Exception e)
        {
            v = null;
            m_Log.error("Error extrayendo festivos");
        }
    finally
        {
                if (sqlExec!=null) sqlExec.close();
        }
        m_Log.debug("extraidos Dias Festivos");
        return v;
    }


    public Vector extraerDiasFestivosCentro(Vector v, String centro, String ubic) throws TechnicalException, GestionException
    {
        m_Log.debug("extraerDiasFestivosCentro");
    //Extrae los dias especificados como festivos para ese centro en concreto
        JDBCWrapper sqlExec = new JDBCWrapper();
        Vector params = new Vector();
        Fecha f = new Fecha();
    Date day = new Date();
        String dia = new String();
    //Obtiene la fecha de inicio y de fin del intervalo del vector
        String fec_i = (String)v.firstElement();
        String fec_f = (String)v.lastElement();
        String sql = new String();
    String campo = new String();
        String valor = new String();
    int indice = -1;
        try
        {
          sql = m_ConfigTechnical.getString("SQL.gen_agenda.selectIntervaloFestivosCentro");
          params.addElement(fec_i);
          params.addElement(fec_f);
      params.addElement(centro);
            params.addElement(ubic);
      sqlExec.execute(sql, params);
      while (sqlExec.next())
          {
        campo = m_ConfigTechnical.getString("SQL.gen_agenda.diaFestivo");
                day = sqlExec.getDate(campo);
                dia = f.obtenerString(day);
        indice = v.indexOf(dia);
        if (indice == -1)
          v = null;
                else
                  v.remove(indice);
      }
    }
        catch (Exception e)
        {
      v = null;
            m_Log.error("Error extraerDiasFestivosCentro");
        }
    finally
        {
                if (sqlExec!=null) sqlExec.close();
        }
        m_Log.debug("extraidos DiasFestivosCentro");
        return v;
    }

  public Vector extraerDomingos(Vector v)
    {
        m_Log.debug("extraerDomingo");
    //Recorre el vector de fechas extrayendo los domingos del mismo
        //Para saber si un dia es domingo emplea metodos de la clase fecha
    Vector domingos = new Vector();
    Fecha f = new Fecha();
        String dia = new String();
        Date d = new Date();
        String day = new String();
    int indice = -1;
        //Recorre el vector de fechas buscando domingos,
        //para crear un vector de domingos
    for (int i = 0; i< v.size(); i++)
    {
            dia = (String)v.elementAt(i);
            d = f.obtenerDate(dia);
      day = f.obtenerDiaSemana(d);
            if ("Domingo".equals(day))
            {
              domingos.addElement(dia);
            }
        }
    //Recorre el vector de domingos, localizandolos en el vector
        //de fechas y eliminandolos del mismo
    for (int i = 0; i<domingos.size(); i++)
        {
      dia = (String)domingos.elementAt(i);
      indice = v.indexOf(dia);
            if (indice == -1)
                v = null;
            else
        v.remove(indice);
        }
        m_Log.debug("extraidos Domingos");
        return v;
    }


    public Vector obtenerHorario(String fecha, String centro, String ubic) throws TechnicalException
    {
    m_Log.debug("obtenerHorario");
    //Obtiene el horario que corresponde a un centro concreto
        //para un dia concreto.
        //Retorna un vector que contiene la hora de inicio y fin
        //de la mañana y la hora de inicio y de fin de la tarde

        //Comprueba si ese centro para ese dia concreto tiene especificaco
        //un horario especial
    Vector v = obtenerHorarioEspecial(fecha, centro, ubic);
    if  ((v != null)&&(v.size() != 0))
            return v;
        else
        {
      //Si no tiene especificado un horario especial, obtiene el horario
            //general para ese centro
      v = obtenerHorarioGeneral(fecha, centro, ubic);
            //Retorna un vector con las horas
          m_Log.debug("obtenido Horario");
          return v;
        }
    }

    public Vector obtenerHorarioEspecial(String fecha, String centro, String ubic) throws TechnicalException
    {
        m_Log.debug("obtenerHorarioEspecial");
    //Obtiene el horario especial especificado para ese centro y esa fecha
    Vector result = new Vector();
        JDBCWrapper sqlExec = new JDBCWrapper();
        String sql = m_ConfigTechnical.getString("SQL.gen_agenda.selectHorarioCentro");
    Vector params = new Vector();
        boolean encontrado = false;
    String campo1 = new String();
    String campo2 = new String();
    String campo3 = new String();
    String campo4 = new String();
    String ini_man = new String();
        String fin_man = new String();
        String ini_tar = new String();
        String fin_tar = new String();
    try
        {
            params.addElement(fecha);
            params.addElement(centro);
            params.addElement(ubic);
      sqlExec.execute(sql, params);
            campo1 = m_ConfigTechnical.getString("SQL.gen_agenda.cenIniMañana");
            campo2 = m_ConfigTechnical.getString("SQL.gen_agenda.cenFinMañana");
            campo3 = m_ConfigTechnical.getString("SQL.gen_agenda.cenIniTarde");
            campo4 = m_ConfigTechnical.getString("SQL.gen_agenda.cenFinTarde");
            while (sqlExec.next())
            {
              encontrado = true;
        //ini_man = String.valueOf(sqlExec.getString(campo1));
        ini_man = sqlExec.getString(campo1) == null ? "25:00" :sqlExec.getString(campo1);
        //fin_man = String.valueOf(sqlExec.getString(campo2));
        fin_man = sqlExec.getString(campo2) == null ? "25:00" :sqlExec.getString(campo2);
        //ini_tar = String.valueOf(sqlExec.getString(campo3));
        ini_tar = sqlExec.getString(campo3) == null ? "25:00" :sqlExec.getString(campo3);
        //fin_tar = String.valueOf(sqlExec.getString(campo4));
        fin_tar = sqlExec.getString(campo4) == null ? "25:00" :sqlExec.getString(campo4);

                result.addElement(ini_man);
                result.addElement(fin_man);
                result.addElement(ini_tar);
                result.addElement(fin_tar);
            }
        }
        catch(Exception e)
    {
      encontrado = false;
            m_Log.error("Error obtenerHorarioEspecial");
        }
    finally
        {
                if (sqlExec!=null) sqlExec.close();
    }
        m_Log.debug("obtenido HorarioEspecial");
    if (encontrado == true)
            return result;
        else
            return null;
    }

    public Vector obtenerHorarioGeneral(String fecha, String centro, String ubic) throws TechnicalException
    {
        m_Log.debug("obtenerHorarioGeneral");
      //Obtiene el horario general especificado para ese centro
      Vector result = new Vector();
        JDBCWrapper sqlExec = new JDBCWrapper();
        String sql = m_ConfigTechnical.getString("SQL.gen_agenda.selectHorarioGeneral");
    Vector params = new Vector();
        boolean encontrado = false;
        Fecha f = new Fecha();
        Date day = f.obtenerDate(fecha);
    try
        {
            String dia = f.obtenerDiaSemana(day);
            params.addElement(centro);
            params.addElement(ubic);
      sqlExec.execute(sql, params);
      String campo1 = new String();
      String campo2 = new String();
      String campo3 = new String();
      String campo4 = new String();
      String ini_man = new String();
            String fin_man = new String();
            String ini_tar = new String();
            String fin_tar = new String();
      //Comprueba que tipo de dia es porque de lunes a viernes
            //hay espacificado un horario y los sabados otro diferente
            if ("Sábado".equals(dia))
            {
              campo1 = m_ConfigTechnical.getString("SQL.gen_agenda.sabIniMañana");
              campo2 = m_ConfigTechnical.getString("SQL.gen_agenda.sabFinMañana");
              campo3 = m_ConfigTechnical.getString("SQL.gen_agenda.sabIniTarde");
              campo4 = m_ConfigTechnical.getString("SQL.gen_agenda.sabFinTarde");
              while (sqlExec.next())
              {
                encontrado = true;
          //ini_man = String.valueOf(sqlExec.getString(campo1));
          ini_man = sqlExec.getString(campo1) == null ? "25:00" :sqlExec.getString(campo1);
          //fin_man = String.valueOf(sqlExec.getString(campo2));
          fin_man = sqlExec.getString(campo2) == null ? "25:00" :sqlExec.getString(campo2);
          //ini_tar = String.valueOf(sqlExec.getString(campo3));
          ini_tar = sqlExec.getString(campo3) == null ? "25:00" :sqlExec.getString(campo3);
          //fin_tar = String.valueOf(sqlExec.getString(campo4));
          fin_tar = sqlExec.getString(campo4) == null ? "25:00" :sqlExec.getString(campo4);
                  result.addElement(ini_man);
                  result.addElement(fin_man);
                  result.addElement(ini_tar);
                  result.addElement(fin_tar);
              }
            }
            else
            {
              campo1 = m_ConfigTechnical.getString("SQL.gen_agenda.genIniMañana");
              campo2 = m_ConfigTechnical.getString("SQL.gen_agenda.genFinMañana");
              campo3 = m_ConfigTechnical.getString("SQL.gen_agenda.genIniTarde");
              campo4 = m_ConfigTechnical.getString("SQL.gen_agenda.genFinTarde");
              while (sqlExec.next())
              {
                encontrado = true;
          //ini_man = String.valueOf(sqlExec.getString(campo1));
          ini_man = sqlExec.getString(campo1) == null ? "25:00" :sqlExec.getString(campo1);
          //fin_man = String.valueOf(sqlExec.getString(campo2));
          fin_man = sqlExec.getString(campo2) == null ? "25:00" :sqlExec.getString(campo2);
          //ini_tar = String.valueOf(sqlExec.getString(campo3));
          ini_tar = sqlExec.getString(campo3) == null ? "25:00" :sqlExec.getString(campo3);
          //fin_tar = String.valueOf(sqlExec.getString(campo4));
          fin_tar = sqlExec.getString(campo4) == null ? "25:00" :sqlExec.getString(campo4);
                  result.addElement(ini_man);
                  result.addElement(fin_man);
                  result.addElement(ini_tar);
                  result.addElement(fin_tar);
              }
      }
        }
        catch(Exception e)
        {
      encontrado = false;
          m_Log.error("error obtenerHorarioGeneral");
        }
    finally
        {
                if (sqlExec!=null) sqlExec.close();
        }
        m_Log.debug("obtenido HorarioGeneral");
    if (encontrado == true)
            return result;
        else
          return null;
    }

  public boolean insertarAgenda(String fecha, Vector horario, String centro, String ubic) throws TechnicalException, GestionException
    {
        m_Log.debug("insertarAgenda");

    //Coje el horario real
        String m_hora_i_real = (String)horario.elementAt(0);
        String m_hora_f_real = (String)horario.elementAt(1);
        String t_hora_i_real = (String)horario.elementAt(2);
        String t_hora_f_real = (String)horario.elementAt(3);

      boolean rdo = true;
    if (((m_hora_i_real != null)&&(m_hora_f_real != null))||((t_hora_i_real != null)&&(t_hora_f_real != null)))
        {

          //Extrae las horas enteras del horario, ignorando los minutos
          String m_hora_i = m_hora_i_real.substring(0,2) + ":00";
          String m_hora_f = m_hora_f_real.substring(0,2) + ":00";
          String t_hora_i = t_hora_i_real.substring(0,2) + ":00";
          String t_hora_f = t_hora_f_real.substring(0,2) + ":00";

          JDBCWrapper sqlExec = new JDBCWrapper();
          String sql = m_ConfigTechnical.getString("SQL.gen_agenda.selectDatosAgenda");
      Vector params = new Vector();
      try
          {
        params.addElement(fecha);
              params.addElement(centro);
              params.addElement(ubic);
        //Obtengo todos los datos de gen_agenda para ese centro, ubicacion y fecha
              //donde personas_ir > 0 o personas_eer > 0
        sqlExec.execute(sql, params);
        int personas_ir = -1;
        int personas_eer = -1;
              String horaIniAgenda = new String();
        String campo1 = new String();
              String campo2 = new String();
              String campo3 = new String();
              campo1 = m_ConfigTechnical.getString("SQL.gen_agenda.personasIR");
            campo2 = m_ConfigTechnical.getString("SQL.gen_agenda.personasEER");
              campo3 = m_ConfigTechnical.getString("SQL.gen_agenda.horaAgenda");
              while (sqlExec.next())
              {
                //Obtengo el número de personas para IR, EER y la hora
          personas_ir = sqlExec.getInt(campo1);
          personas_eer = sqlExec.getInt(campo2);
                  horaIniAgenda = String.valueOf(sqlExec.getString(campo3));
          //Si la hora obtenida está comprendida entre la de inicio y la de fin de la mañana o de la tarde
                  if (((horaIniAgenda.compareTo(m_hora_i) >= 0) && (horaIniAgenda.compareTo(m_hora_f) <= 0)) || ((horaIniAgenda.compareTo(t_hora_i) >= 0) && (horaIniAgenda.compareTo(t_hora_f) <= 0)))
                  {
                      boolean resdo = true;
            if (personas_ir != 0)
                    {
                            //Si el numero de personas IR es > 0, obtengo los datos a insertar en la BD
                        resdo = generarDatosAgenda(centro, ubic, fecha, "1", horaIniAgenda, personas_ir, horario);
            }
                      if (personas_eer != 0)
                      {
                            //Si el numero de personas EER es > 0, obtengo los datos a insertar en la BD
                        resdo = generarDatosAgenda(centro, ubic, fecha, "2", horaIniAgenda, personas_eer, horario);
                      }
                  }
              }
          }
          catch(Exception e)
          {
              rdo = false;
            m_Log.error("error insertarAgenda");
          }
          finally
          {
                if (sqlExec!=null) sqlExec.close();
          }
        }
        m_Log.debug("insertada Agenda");
    return rdo;
    }


    public boolean generarDatosAgenda(String centro, String ubic, String fecha, String tipo, String horaInicio, int personas, Vector horario) throws TechnicalException
    {
        m_Log.debug("generarDatosAgenda");

    //Obtengo el horario
        String m_hora_i_real = (String)horario.elementAt(0);
        String m_hora_f_real = (String)horario.elementAt(1);
        String t_hora_i_real = (String)horario.elementAt(2);
        String t_hora_f_real = (String)horario.elementAt(3);

        if (m_Log.isDebugEnabled()) m_Log.debug("              Generando datos: .... Fecha: " + fecha+" HoraInicio: " +horaInicio);
    //Genera los datos q se deberan insertar en la agenda
        String gen_cen_cod_centro = centro;
        String gen_cen_cod_ubic = ubic;
        String gen_age_funcion = tipo;
        Fecha f = new Fecha();
    int anyo = f.getAnoInteger(fecha) - 1900;
        int mes = f.getMesInteger(fecha);
        int dia = f.getDiaInteger(fecha);
    int horas = f.getHorasInteger(horaInicio);
    int mins = f.getMinutosInteger(horaInicio);
        //Crea un objeto de tipo date con la hora y la fecha
    Date day = new Date (anyo, mes, dia, horas, mins);
    //Creamos un objeto de tipo Calendar, el cual iremos incrementando
        //la cantidad de tiempo necesaria
        Calendar c = Calendar.getInstance();
        c.setTime(day);
    //Creamos un objeto de tipo calendar, al cual añadimos
        //una hora. Lo empleamos para comparar con el anterior
    Calendar aux = Calendar.getInstance();
    aux.setTime(day);
        aux.add(aux.MINUTE, 60);


        String fecha_aux = f.construirHora(aux.getTime());
        int minutos;
        Date day_aux;
        //Si la hora de inicio de mañana está comprendida entre la hora q se trata actualmente y la siguiente hora
        //es porque no se trata de una hora exacta
    //Se pone como hora de inicio la del horario
        if ((m_hora_i_real.compareTo(horaInicio) > 0) && ((m_hora_i_real.compareTo(fecha_aux)) < 0))
        {
            minutos = Integer.parseInt(m_hora_i_real.substring(3,5));
      day_aux = new Date (anyo, mes, dia, horas, minutos);
      c.setTime(day_aux);
        }
        //Si la hora de fin de mañana está comprendida entre la hora q se trata actualmente y la siguiente hora
        //es porque no se trata de una hora exacta
    //Se pone como hora de fin la del horario
        if ((m_hora_f_real.compareTo(horaInicio) > 0) && ((m_hora_f_real.compareTo(fecha_aux)) < 0))
      {
            minutos = Integer.parseInt(m_hora_f_real.substring(3,5));
      day_aux = new Date (anyo, mes, dia, horas, minutos);
            aux.setTime(day_aux);
    }
    //Si no es así, se trata de una hora exacta, la de fin será la hora anterior
        else if (m_hora_f_real.compareTo(horaInicio) == 0)
            aux.add(aux.MINUTE, -60);

        //Si la hora de inicio de tarde está comprendida entre la hora q se trata actualmente y la siguiente hora
        //es porque no se trata de una hora exacta
    //Se pone como hora de inicio la del horario
        if ((t_hora_i_real.compareTo(horaInicio) > 0) && ((t_hora_i_real.compareTo(fecha_aux)) < 0))
        {
            minutos = Integer.parseInt(t_hora_i_real.substring(3,5));
      day_aux = new Date (anyo, mes, dia, horas, minutos);
            c.setTime(day_aux);
        }
        //Si la hora de fin de tarde está comprendida entre la hora q se trata actualmente y la siguiente hora
        //es porque no se trata de una hora exacta
    //Se pone como hora de fin la del horario
        if ((t_hora_f_real.compareTo(horaInicio) > 0) && ((t_hora_f_real.compareTo(fecha_aux)) < 0))
        {
            minutos = Integer.parseInt(t_hora_f_real.substring(3,5));
      day_aux = new Date (anyo, mes, dia, horas, minutos);
            aux.setTime(day_aux);
        }
    //Si no es así, se trata de una hora exacta, la de fin será la hora anterior
        else if (t_hora_f_real.compareTo(horaInicio) == 0)
            aux.add(aux.MINUTE, -60);


        Date gen_age_hora_ini = new Date();
    Date gen_age_hora_fin = new Date();

    int gen_age_num_max = 0;
    int numero = -1;
        int duracion = -1;
    //Si el tipo de inserción es de tipo 1, se extraen del fichero
        //de configuración los valores correspondientes
    if ("1".equals(tipo))
        {
      numero = m_ConfigLangai.getInt("gestion.numero_ir");
      duracion = m_ConfigLangai.getInt("gestion.duracion_ir");
        }
    //Si el tipo de inserción es de tipo 2, se extraen del fichero
        //de configuración los valores correspondientes
        else if ("2".equals(tipo))
        {
      numero = m_ConfigLangai.getInt("gestion.numero_eer");
      duracion = m_ConfigLangai.getInt("gestion.duracion_eer");
        }
    boolean rsdo = false;
    //Incrementamos la hora en la unidad especificada en el fichero de
        //configuración hasta q alcance la hora siguiente
        while (c.before(aux))
    {
                gen_age_hora_ini = c.getTime();
        c.add(c.MINUTE, duracion);
              gen_age_hora_fin = c.getTime();
        gen_age_num_max = personas * numero;
        //Insertamos los datos en la BD
                if (!aux.before(c))
                  rsdo = insertarDatosAgenda(gen_cen_cod_centro, gen_cen_cod_ubic, gen_age_funcion, gen_age_hora_ini, gen_age_hora_fin, gen_age_num_max, gen_age_num_max);
      }
        m_Log.debug("generados DatosAgenda");
        return rsdo;
    }

  public boolean insertarDatosAgenda(String gen_cen_cod_centro, String gen_cen_cod_ubic, String gen_age_funcion, Date age_hora_ini, Date age_hora_fin, int age_num_max, int age_num_disp) throws TechnicalException
    {

        m_Log.debug("insertarDatosAgenda");
    //Insertamos los datos en la BD
    Fecha f = new Fecha();

        XAJDBCWrapper sqlExec = new XAJDBCWrapper();

    Integer gen_age_num_max = new Integer(age_num_max);
    Integer gen_age_num_disp = new Integer(age_num_disp);

        Vector params = new Vector();
        boolean rdo = true;
        if (m_Log.isDebugEnabled()){
            //m_Log.info("Generando la agenda para los datos.........");
            m_Log.debug("Codigo del centro: " + gen_cen_cod_centro);
        }
        params.add(gen_cen_cod_centro);
        if (m_Log.isDebugEnabled()) m_Log.debug("Codigo de ubicacion: " + gen_cen_cod_ubic);
        params.add(gen_cen_cod_ubic);
        if (m_Log.isDebugEnabled()) m_Log.debug("Funcion: " + gen_age_funcion);
        params.add(gen_age_funcion);
        if (m_Log.isDebugEnabled()) m_Log.debug("Hora inicio: " + age_hora_ini);
        params.add(age_hora_ini);
        if (m_Log.isDebugEnabled()) m_Log.debug("Hora fin: " + age_hora_fin);
        params.add(age_hora_fin);
        if (m_Log.isDebugEnabled()) m_Log.debug("N max: " + gen_age_num_max);
        params.add(gen_age_num_max);
        if (m_Log.isDebugEnabled()) m_Log.debug("N disp: " + gen_age_num_disp);
        params.add(gen_age_num_disp);

        String sql = m_ConfigTechnical.getString("SQL.gen_agenda.insertarAgenda");
  try
        {
      sqlExec.execute(sql, params);
        }
        catch (Exception e)
        {
          m_Log.error("error insertarDatosAgenda");
      rdo = false;
        }
    finally
        {
                if (sqlExec!=null) sqlExec.close();
        }
        m_Log.debug("insertados DatosAgenda");
    return rdo;
    }






    /**
     * Obtiene el n dia laboral anterior al que recibe como parametro
     * @param     Fecha, fecha a partir de la cual quiere conocer el día anterior laboral
     * @param     num, numero de días anteriores laborales
     * @param     centro, codigo del centro
     * @param     ubic, codigo de la ubicacion
     * @exception GestionException si existe algun problema tecnico.
     * @exception TechnicalException si hay algun problema tecnico.
     */
    public String obtenerDiaLaboralAtras(String fecha, int numero, String centro, String ubic) throws GestionException, TechnicalException
    {
    String dia_anterior = "";
      Fecha f = new Fecha();
    Vector dias = new Vector();
    int numAux = numero;
    while (dias.size() < numero)
    {
      numAux = numAux * 10;
      dias = obtenerVectorDiasAtras(f.obtenerDate(fecha), numAux);
          dias = obtenerDiasLaborables(dias, centro, ubic);
  }

        dia_anterior = (String)dias.elementAt(numero);
        if (m_Log.isDebugEnabled())  m_Log.debug(dia_anterior);
        return dia_anterior;

    }

    /**
     * Obtiene un vector con n dias atras
     * @param     Fecha, fecha a partir de la cual crear el vector
     * @param     num, numero de días anteriores que debe tener el vector
     * @return    Vector de Días
     * @exception GestionException si existe algun problema tecnico.
     * @exception TechnicalException si hay algun problema tecnico.
     */
     public Vector obtenerVectorDiasAtras(Date f_i, int numero) throws GestionException, TechnicalException
    {
        //Crea un vector con los dias comprendidos en el intervalo seleccionado
        //El vector es un vector de strings
        m_Log.debug("obtenerVectorDiasAtras");
  Vector v = new Vector();
        Fecha f = new Fecha();
        Date d = new Date();
  //Se crea un objeto de tipo Calendar para ir aumentando la fecha
        Calendar cal = Calendar.getInstance();
        cal.setTime(f_i);
        int j = numero;
  while(numero >= 0)
  {
    //Añade un dia hasta llegar al ultimo dia del intervalo
    cal.add(cal.DATE, -1);
                d = cal.getTime();
    if (m_Log.isDebugEnabled())  m_Log.debug(f.obtenerString(d));
              v.addElement(f.obtenerString(d));
              j = j - 1;
       }
       //retorna el vector
       m_Log.debug("obtenido vector dias atras");
       return v;
    }



    public Vector obtenerEntrevistadoresDia (String dia, String cod_centro, String cod_ubic) throws GestionException, TechnicalException
    {
      if (m_Log.isDebugEnabled()) m_Log.debug("******************** Obteniendo entrevistadores Necesarios para el día: " + dia);
      Vector horario = obtenerHorario(dia, cod_centro, cod_ubic);
      String hora_m_i = (String)horario.elementAt(0);
      String hora_m_f = (String)horario.elementAt(1);
      String hora_t_i = (String)horario.elementAt(2);
      String hora_t_f = (String)horario.elementAt(3);
  Fecha f = new Fecha();
  Vector horario_total = new Vector();
  try
  {
        if ((!"".equals(hora_m_i)) && (!"".equals(hora_m_f)))
        {
          Calendar cal_ini = f.obtenerCalendar(dia, hora_m_i);
      Calendar cal_fin = f.obtenerCalendar(dia, hora_m_f);
      while (cal_fin.after(cal_ini))
      {
        String f_inicio = f.obtenerStringCompleto(cal_ini.getTime());
        String fecha_param = f.obtenerString(cal_ini.getTime());
        String hora_param = f.obtenerHoraDeFechaCompleta(f_inicio).trim();
        if (m_Log.isDebugEnabled()) m_Log.debug("--- Inicio: " + f_inicio);
        Vector v = obtenerEntrevistadoresHora(fecha_param, hora_param, cod_centro, cod_ubic);
        horario_total.addElement(v);
        cal_ini.add(cal_ini.HOUR, 1);
        String f_fin = f.obtenerStringCompleto(cal_ini.getTime());
        if (m_Log.isDebugEnabled()) m_Log.debug("--- Fin: " + f_fin);
      }
    }

        if ((!"".equals(hora_t_i)) && (!"".equals(hora_t_f)))
        {
          Calendar cal_ini = f.obtenerCalendar(dia, hora_t_i);
      Calendar cal_fin = f.obtenerCalendar(dia, hora_t_f);
      while (cal_fin.after(cal_ini))
      {
        String f_inicio = f.obtenerStringCompleto(cal_ini.getTime());
        String fecha_param = f.obtenerString(cal_ini.getTime());
        String hora_param = f.obtenerHoraDeFechaCompleta(f_inicio).trim();
        if (m_Log.isDebugEnabled()) m_Log.debug("--- Inicio: " + f_inicio);
        Vector v = obtenerEntrevistadoresHora(fecha_param, hora_param, cod_centro, cod_ubic);
        horario_total.addElement(v);
        cal_ini.add(cal_ini.HOUR, 1);
        String f_fin = f.obtenerStringCompleto(cal_ini.getTime());
        if (m_Log.isDebugEnabled()) m_Log.debug("--- Fin: " + f_fin);
      }
    }
    m_Log.debug("ENTREVISTADORES:..........................");
    for (int i = 0; i < horario_total.size(); i++)
    {
      Vector v = (Vector)horario_total.elementAt(i);
      m_Log.debug("Total: " );
      if (m_Log.isDebugEnabled()) m_Log.debug((String)v.elementAt(0) + " " + (String)v.elementAt(1) + " " + (String)v.elementAt(2) + " " + (String)v.elementAt(3));
    }
  }
  catch(Exception e)
  {
    m_Log.error("error buscando entrevistadores para un día");
    throw new GestionException("Error obteniendo entrevistadores necesarios para un día");
  }
        m_Log.debug("obtenido vector de entrevistadores necesarios por día");
  return horario_total;
    }

    public Vector obtenerEntrevistadoresHora(String fecha, String hora, String cod_centro, String cod_ubic) throws GestionException, TechnicalException
    {
        m_Log.debug("obtenerEntrevistadoresHora");
        JDBCWrapper sqlExec = new JDBCWrapper();
        Vector result = new Vector();
  try
  {
    m_Log.debug("*********************** Obtener Entrevistadores Hora");
    Fecha f = new Fecha();
    Calendar cal = f.obtenerCalendar(fecha, hora);
    String f_inicio = f.obtenerStringCompleto(cal.getTime());
    cal.add(cal.HOUR, 1);
    String f_fin = f.obtenerStringCompleto(cal.getTime());
    if (m_Log.isDebugEnabled()) m_Log.debug("                                       HORA INICIO: " + f_inicio + " HORA FIN: " + f_fin);
    String sql = m_ConfigTechnical.getString("SQL_gen_agenda.obtenerEntrevistadores");
    Vector params = new Vector();
    params.addElement(f_inicio);
    params.addElement(f_fin);
    params.addElement(new Integer(1));
    params.addElement(cod_centro);
    params.addElement(cod_ubic);
    int numero_ir = m_ConfigLangai.getInt("gestion.numero_ir");
    int max_entrev_ir = 0;
    if (m_Log.isDebugEnabled()) m_Log.debug("se va acceder a la BD para buscar los entrevistadores necesarios para el día " + fecha + " , hora: " + hora + " y funcion = 1");
    sqlExec.execute(sql, params);
    while (sqlExec.next())
    {
      int j = 1;
      if (m_Log.isDebugEnabled()) m_Log.debug("                                       " + sqlExec.getString(m_ConfigTechnical.getString("SQL.gen_agenda.hora_Inicio")) + " " + sqlExec.getString(m_ConfigTechnical.getString("SQL.gen_agenda.hora_Fin")));
      int citas = sqlExec.getInt(m_ConfigTechnical.getString("SQL.gen_agenda.max_citas")) - sqlExec.getInt(m_ConfigTechnical.getString("SQL.gen_agenda.disp_citas"));
      if (m_Log.isDebugEnabled()) m_Log.debug("                                       Citas: " + citas);
      if (citas == 0)
        j = 0;
      else
      {
        while (citas > numero_ir * j)
        {
          j++;
        }
      }
      if (max_entrev_ir < j)
        max_entrev_ir = j;
    }
          m_Log.debug("entrevistadores obtenidos");
    params = new Vector();
    params.addElement(f_inicio);
    params.addElement(f_fin);
    params.addElement(new Integer(2));
    params.addElement(cod_centro);
    params.addElement(cod_ubic);
    int numero_eer = m_ConfigLangai.getInt("gestion.numero_eer");
    int max_entrev_eer = 0;
    if (m_Log.isDebugEnabled()) m_Log.debug("se va acceder a la BD para buscar los entrevistadores necesarios para el día " + fecha + " , hora: " + hora + " y funcion = 2");
    sqlExec.execute(sql, params);
    while (sqlExec.next())
    {
      int j = 1;
      if (m_Log.isDebugEnabled()) m_Log.debug("                                       " + sqlExec.getString(m_ConfigTechnical.getString("SQL.gen_agenda.hora_Inicio")) + " " +sqlExec.getString(m_ConfigTechnical.getString("SQL.gen_agenda.hora_Fin")));
      int citas = sqlExec.getInt(m_ConfigTechnical.getString("SQL.gen_agenda.max_citas")) - sqlExec.getInt(m_ConfigTechnical.getString("SQL.gen_agenda.disp_citas"));
      if (m_Log.isDebugEnabled()) m_Log.debug("                                       Citas: " + citas);
      if (citas == 0)
        j = 0;
      else
      {
        while (citas > numero_eer * j)
        {
          j++;
        }
      }
      if (max_entrev_eer < j)
        max_entrev_eer = j;
    }
          m_Log.debug("entrevistadores obtenidos");
    result.addElement(fecha);
    result.addElement(hora);
    result.addElement(new Integer(max_entrev_ir).toString());
    result.addElement(new Integer(max_entrev_eer).toString());
  }
  catch(Exception e)
  {
          m_Log.error("Error tratando de obtener entrevistadores para una hora");
    throw new GestionException("Algun error obteniendo los entrevistadores necesarios para una hora");
  }
  finally
  {
                if (sqlExec!=null) sqlExec.close();
  }
        m_Log.debug("obtenidos los entrevistadores para una hora");
  return result;
    }




    public Vector obtenerDatosEntrevistas(String fec_i, String fec_f, String centro, String ubic) throws TechnicalException, GestionException
    {
        if (m_Log.isDebugEnabled()) m_Log.debug("*** Obteniendo los datos anteriores de entrevistas del intervalo: " + fec_i + " " + fec_f);
        String sql = m_ConfigTechnical.getString("SQL.gen_agenda.obtenerCitasAgendaAnterior");
        Fecha f = new Fecha();
        JDBCWrapper sqlExec = new JDBCWrapper();
  Vector v = new Vector();
  try
        {
    Vector params = new Vector();
    params.addElement(fec_i);
    params.addElement(fec_f);
    params.addElement(centro);
    params.addElement(ubic);
    if (m_Log.isDebugEnabled()) m_Log.debug("Obteniendo de gen_agenda los datos de entrevistas del intervalo: " + fec_i + " " + fec_f);
    sqlExec.execute(sql, params);
    while (sqlExec.next())
    {
      AgendaValueObject laAgenda = new AgendaValueObject();
      laAgenda.setCod_centro(sqlExec.getString(m_ConfigTechnical.getString("SQL.gen_agenda.codCentro")));
      laAgenda.setCod_ubic(sqlExec.getString(m_ConfigTechnical.getString("SQL.gen_agenda.ubicCentro")));
      laAgenda.setAge_funcion(sqlExec.getString(m_ConfigTechnical.getString("SQL.gen_agenda.funcion")));
      Date f_ini = sqlExec.getDateTimeStamp(m_ConfigTechnical.getString("SQL.gen_agenda.hora_Inicio"));
      Date f_fin = sqlExec.getDateTimeStamp(m_ConfigTechnical.getString("SQL.gen_agenda.hora_Fin"));
      if (m_Log.isDebugEnabled()) m_Log.debug("                             " + f.obtenerStringCompleto(f_ini) + " " + f.obtenerStringCompleto(f_fin));
      laAgenda.setHora_ini(f.obtenerStringCompleto(f_ini));
      laAgenda.setHora_fin(f.obtenerStringCompleto(f_fin));
      laAgenda.setNum_max(sqlExec.getInt(m_ConfigTechnical.getString("SQL.gen_agenda.max_citas")));
      laAgenda.setNum_disp(sqlExec.getInt(m_ConfigTechnical.getString("SQL.gen_agenda.disp_citas")));
      v.addElement(laAgenda);
    }
    if (m_Log.isDebugEnabled()) m_Log.debug("Obtenidos los datos de entrevistas del intervalo: " + fec_i + " " + fec_f);
  }
  catch(Exception e)
  {
          m_Log.error("Error tratando de obtener las entrevistas anteriores");
    throw new GestionException("Error tratando de obtener las entrevistas anteriores");
  }
      finally
      {
                if (sqlExec!=null) sqlExec.close();
      }
      m_Log.debug("Obtenidos los datos de las entrevistas anteriores");
      return v;
    }

    public void modificarAgendaEntrevistas(Vector v)  throws TechnicalException, GestionException
    {
        m_Log.debug("modificarAgendaEntrevistas");
        m_Log.debug("*** Recuperando las citas anteriores");
        String sql = m_ConfigTechnical.getString("SQL.gen_agenda.modificarCitasAgendaAnterior");
        XAJDBCWrapper sqlExec = new XAJDBCWrapper();
        try
        {
          for (int i = 0; i < v.size(); i++)
          {
            AgendaValueObject avo = (AgendaValueObject) v.elementAt(i);
            int diferencia = avo.getNum_max() - avo.getNum_disp();
            if (m_Log.isDebugEnabled()) m_Log.debug("Diferencia: " + diferencia);
            Vector params = new Vector();
            params.addElement(new Integer(diferencia));
            params.addElement(avo.getCod_centro());
            params.addElement(avo.getCod_ubic());
            params.addElement(avo.getHora_ini());
            params.addElement(avo.getHora_fin());
            params.addElement(avo.getAge_funcion());
            //if (m_Log.isInfoEnabled()) m_Log.info("Antes de recuperar las citas para: " + avo.getHora_ini() + " " + avo.getHora_fin() + " y funcion: " + avo.getAge_funcion());
            sqlExec.execute(sql, params);

            if (m_Log.isDebugEnabled()) m_Log.debug("                   Recuperando citas para la hora: " + avo.getHora_ini() + " " + avo.getHora_fin() + " y la funcion " + avo.getAge_funcion());
          }
          //m_Log.info("Recuperada la agenda");
        }
        catch(Exception e)
        {
          m_Log.error("Error tratando de recuperar las entrevistas anteriores");
    throw new GestionException("Error tratando de recuperar las entrevistas anteriores");
        }
      finally
      {
                if (sqlExec!=null) sqlExec.close();
      }
      m_Log.debug("modificarAgendaEntrevistas");
    }

  //fin Raquel

    /**
     * Factory method para el<code>Singelton</code>.
     * @return La unica instancia de ExperienciaDAO The only CustomerDAO instance.
     */
    public static AgendaDAO getInstance() {
        //si no hay ninguna instancia de esta clase tenemos que crear una
        if (instance == null) {
            // Necesitamos sincronizacion para serializar (no multithread)
            // Las invocaciones de este metodo
            synchronized(AgendaDAO.class) {
                if (instance == null) {
                    instance = new AgendaDAO();
                }
            }
        }
        return instance;
    }

     /*
     * Mi propia instancia. Usada en el metodo getInstance
     */

    private static AgendaDAO instance = null;

     /*
     * Declaracion de servicios
     */

    protected static Config m_ConfigTechnical; //Para el fichero de configuracion tecnico
    protected static Config m_ConfigError; //Para los mensajes de error localizados
    protected static Log m_Log =
          LogFactory.getLog(AgendaDAO.class.getName());

    protected static Config m_ConfigLangai; //Para información de los parámetros de Langai

}
